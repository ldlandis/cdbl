head	1.74;
access;
symbols;
locks; strict;
comment	@ * @;


1.74
date	96.04.08.00.05.55;	author ldl;	state Exp;
branches;
next	1.73;

1.73
date	96.03.08.12.53.51;	author ldl;	state Exp;
branches;
next	1.72;

1.72
date	96.01.31.12.05.54;	author ldl;	state Exp;
branches;
next	1.71;

1.71
date	96.01.17.09.44.23;	author ldl;	state Exp;
branches;
next	1.70;

1.70
date	95.11.20.18.53.00;	author ldl;	state Exp;
branches;
next	1.69;

1.69
date	95.11.11.11.15.10;	author ldl;	state Exp;
branches;
next	1.68;

1.68
date	95.11.03.09.20.05;	author ldl;	state Exp;
branches;
next	1.67;

1.67
date	95.10.24.08.27.36;	author ldl;	state Exp;
branches;
next	1.66;

1.66
date	95.10.23.09.19.34;	author ldl;	state Exp;
branches;
next	1.65;

1.65
date	95.10.19.02.07.25;	author ldl;	state Exp;
branches;
next	1.64;

1.64
date	95.09.28.09.40.08;	author ldl;	state Exp;
branches;
next	1.63;

1.63
date	95.09.19.10.41.30;	author ldl;	state Exp;
branches;
next	1.62;

1.62
date	95.09.11.10.27.11;	author ldl;	state Exp;
branches;
next	1.61;

1.61
date	95.09.08.10.47.00;	author ldl;	state Exp;
branches;
next	1.60;

1.60
date	95.09.06.10.45.58;	author ldl;	state Exp;
branches;
next	1.59;

1.59
date	95.09.05.11.44.00;	author ldl;	state Exp;
branches;
next	1.58;

1.58
date	95.09.04.12.12.43;	author ldl;	state Exp;
branches;
next	1.57;

1.57
date	95.08.02.12.38.58;	author ldl;	state Exp;
branches;
next	1.56;

1.56
date	95.08.01.11.52.05;	author ldl;	state Exp;
branches;
next	1.55;

1.55
date	95.07.21.12.24.48;	author ldl;	state Exp;
branches;
next	1.54;

1.54
date	95.07.18.12.39.25;	author ldl;	state Exp;
branches;
next	1.53;

1.53
date	95.07.17.12.40.49;	author ldl;	state Exp;
branches;
next	1.52;

1.52
date	95.07.12.14.07.17;	author ldl;	state Exp;
branches;
next	1.51;

1.51
date	95.07.05.12.50.47;	author ldl;	state Exp;
branches;
next	1.50;

1.50
date	95.07.03.12.17.39;	author ldl;	state Exp;
branches;
next	1.49;

1.49
date	95.06.30.11.14.44;	author ldl;	state Exp;
branches;
next	1.48;

1.48
date	95.06.29.09.14.21;	author ldl;	state Exp;
branches;
next	1.47;

1.47
date	95.06.28.09.53.03;	author ldl;	state Exp;
branches;
next	1.46;

1.46
date	95.06.23.11.19.22;	author ldl;	state Exp;
branches;
next	1.45;

1.45
date	95.06.21.12.40.42;	author ldl;	state Exp;
branches;
next	1.44;

1.44
date	95.06.20.12.17.31;	author ldl;	state Exp;
branches;
next	1.43;

1.43
date	95.06.15.09.12.44;	author ldl;	state Exp;
branches;
next	1.42;

1.42
date	95.06.14.08.57.35;	author ldl;	state Exp;
branches;
next	1.41;

1.41
date	95.06.12.11.37.02;	author ldl;	state Exp;
branches;
next	1.40;

1.40
date	95.06.12.09.15.28;	author ldl;	state Exp;
branches;
next	1.39;

1.39
date	95.06.09.11.19.42;	author ldl;	state Exp;
branches;
next	1.38;

1.38
date	95.06.06.11.47.20;	author ldl;	state Exp;
branches;
next	1.37;

1.37
date	95.05.15.10.22.11;	author ldl;	state Exp;
branches;
next	1.36;

1.36
date	95.05.02.10.43.19;	author ldl;	state Exp;
branches;
next	1.35;

1.35
date	95.04.25.11.48.28;	author ldl;	state Exp;
branches;
next	1.34;

1.34
date	95.04.24.12.23.14;	author ldl;	state Exp;
branches;
next	1.33;

1.33
date	95.04.23.12.55.13;	author ldl;	state Exp;
branches;
next	1.32;

1.32
date	95.04.22.12.42.51;	author ldl;	state Exp;
branches;
next	1.31;

1.31
date	95.04.19.11.29.08;	author ldl;	state Exp;
branches;
next	1.30;

1.30
date	95.04.18.12.00.39;	author ldl;	state Exp;
branches;
next	1.29;

1.29
date	95.04.13.10.23.55;	author ldl;	state Exp;
branches;
next	1.28;

1.28
date	95.04.03.11.47.10;	author ldl;	state Exp;
branches;
next	1.27;

1.27
date	95.03.27.03.06.27;	author ldl;	state Exp;
branches;
next	1.26;

1.26
date	95.03.26.19.58.13;	author ldl;	state Exp;
branches;
next	1.25;

1.25
date	95.03.23.13.31.32;	author ldl;	state Exp;
branches;
next	1.24;

1.24
date	95.03.19.23.29.18;	author ldl;	state Exp;
branches;
next	1.23;

1.23
date	95.03.08.13.33.27;	author ldl;	state Exp;
branches;
next	1.22;

1.22
date	95.03.06.12.00.16;	author ldl;	state Exp;
branches;
next	1.21;

1.21
date	95.03.06.10.31.57;	author ldl;	state Exp;
branches;
next	1.20;

1.20
date	95.03.05.03.24.36;	author ldl;	state Exp;
branches;
next	1.19;

1.19
date	95.03.03.12.36.18;	author ldl;	state Exp;
branches;
next	1.18;

1.18
date	95.02.27.12.55.27;	author ldl;	state Exp;
branches;
next	1.17;

1.17
date	95.02.26.10.54.27;	author ldl;	state Exp;
branches;
next	1.16;

1.16
date	95.01.07.15.34.52;	author ldl;	state Exp;
branches;
next	1.15;

1.15
date	95.01.07.11.22.34;	author ldl;	state Exp;
branches;
next	1.14;

1.14
date	94.12.31.02.31.30;	author ldl;	state Exp;
branches;
next	1.13;

1.13
date	94.12.30.21.01.48;	author ldl;	state Exp;
branches;
next	;


desc
@@


1.74
log
@1996-Apr-07 Checkpoint
@
text
@/***
 * $Source: /home/ldl/dbl/cdbl/RCS/generate.c,v $
 * $Revision: 1.73 $ $Date: 1996/03/08 12:53:51 $
 */

/***
 *	Generate code from parse tree.
 *
 *	See the documentation in node.h for more information.
 *	Note: Assumes that gram.h includes node.h.
 */

/***
 *	Generated elements lexicon.
 *
 *  Global
 *  Variable           Type        Usage
 *  ------------------ ----------  -------------------------------------
 *  __errortrap        char *      Error trap label name
 *  __errortrap_trigger int        An error trap was triggered (in subr)
 *
 *  Local
 *  Variable           Type        Usage
 *  ------------------ ----------  -------------------------------------
 *  __an_arg           DBLArg_t    Single argument
 *  __arg[]            DBLArg_t    Vector of arguments (e.g. XCALL)
 *  __blkname          char*       Name of this block
 *  __call_return[]    int         Runtime call return stack
 *  __call_stack       int         Pointer into __call_return[]
 *  __col              int         Selected display column
 *  __format[]         char        Format string (for numeric formatting)
 *  __iexpr            int         Expression result (as an int)
 *  __io_channel       int         Specified I/O channel
 *  __io_status        IOS_t       I/O status result of I/O operation
 *  __ipos             int         Substring starting character position
 *  __isize            int         Substring size in characters
 *  __loffset          long        Substring starting offset
 *  __n_0, __n_1, ...  Llong       Numeric (cached) value
 *  __n_dec            int         Number of significant decimals
 *  __nby              Llong       "FOR" 'step' value
 *  __nexpr            Llong       Expression result (full precision)
 *  __nthru            Llong       "FOR" ending value
 *  __number[]         char        Stringified numeric temp storage
 *  __prev_errortrap   char *      Error trap label name on subr entry
 *  __row              int         Selected display row
 *  __string[]         char        String temp storage
 *  __xargbuf[]        char        Used as temp storage for parameter(s)
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "prototype.h"
#include "assert.h"
#include "cdbl.h"
#include "gram.h"
#include "parse.h"
#include "_tokens.h"
#include "cdbl_rt.h"


/**
 *	Local define
 */
#define	INDENT	indent*2, ""
#define MAX_BLOCK_DEPTH 50
#define MAX_CALL_ARGS	30
#define MAX_TMP_ARGS	20

#define	LABEL_JIMMIE	"CDBL_L_"

/**
 *	Local functions
 */
static
void      g_close_file	PROTOARGS((void)),
	  g_data_buffers PROTOARGS((Node_id, int, int)),
	  g_data_defs	PROTOARGS((void)),
	  g_data_init	PROTOARGS((Node_id, int, int)),
	  g_data_init_ele PROTOARGS((Node_id, int, int)),
	  g_header	PROTOARGS((void)),
	  g_open_file	PROTOARGS((void)),
	  g_proc	PROTOARGS((void)),
	  g_proc__FATAL	PROTOARGS((Node_id)),
	  g_proc__call_return PROTOARGS((void)),
	  g_proc__error_trap PROTOARGS((void)),
	  g_proc_code	PROTOARGS((Node_id, int, int)),
	  g_proc_decl	PROTOARGS((void)),
	  g_proc_decl_init PROTOARGS((int)),
	  g_proc_decl_params PROTOARGS((Node_id, int, int)),
	  g_proc_decl_toarg_fixup PROTOARGS((Node_id, int, int)),
	  g_proc_decl_toargs PROTOARGS((void)),
          g_proc_mkarg_subr PROTOARGS((Node_id,int*,char*,char*,char**)),
	  g_proc_mkargs	PROTOARGS((int *, Node_id)),
	  g_proc_stmts	PROTOARGS((Node_id)),
	  g_proc_assign PROTOARGS((Node_id)),
	  g_proc_ACCEPT	PROTOARGS((Node_id)),
	  g_proc_BEGIN	PROTOARGS((Node_id)),
	  g_proc_CALL	PROTOARGS((Node_id)),
	  g_proc_CASE	PROTOARGS((Node_id)),
	  g_proc_CLEAR	PROTOARGS((Node_id)),
	  g_proc_CLOSE	PROTOARGS((Node_id)),
	  g_proc_DECR	PROTOARGS((Node_id)),
	  g_proc_DELETE	PROTOARGS((Node_id)),
	  g_proc_DETACH	PROTOARGS((Node_id)),
	  g_proc_DISPLAY PROTOARGS((Node_id)),
	  g_proc_DO	PROTOARGS((Node_id)),
	  g_proc_END	PROTOARGS((Node_id)),
	  g_proc_EXIT	PROTOARGS((Node_id)),
	  g_proc_EXITLOOP PROTOARGS((Node_id)),
	  g_proc_FIND	PROTOARGS((Node_id)),
	  g_proc_FLUSH	PROTOARGS((Node_id)),
	  g_proc_FOR	PROTOARGS((Node_id)),
	  g_proc_FORMS	PROTOARGS((Node_id)),
	  g_proc_FRETURN PROTOARGS((Node_id)),
	  g_proc_GET	PROTOARGS((Node_id)),
	  g_proc_GETS	PROTOARGS((Node_id)),
	  g_proc_GOTO	PROTOARGS((Node_id)),
	  g_proc_IF	PROTOARGS((Node_id)),
	  g_proc_INCR	PROTOARGS((Node_id)),
	  g_proc_LABEL	PROTOARGS((Node_id)),
	  g_proc_LOCASE	PROTOARGS((Node_id)),
	  g_proc_LPQUE	PROTOARGS((Node_id)),
	  g_proc_NEXTLOOP PROTOARGS((Node_id)),
	  g_proc_NOP	PROTOARGS((Node_id)),
	  g_proc_OFFERROR PROTOARGS((Node_id)),
	  g_proc_ONERROR PROTOARGS((Node_id)),
	  g_proc_OPEN	PROTOARGS((Node_id)),
	  g_proc_PUT	PROTOARGS((Node_id)),
	  g_proc_PUTS	PROTOARGS((Node_id)),
	  g_proc_READ	PROTOARGS((Node_id)),
	  g_proc_READS	PROTOARGS((Node_id)),
	  g_proc_RECV	PROTOARGS((Node_id)),
	  g_proc_REPEAT	PROTOARGS((Node_id)),
	  g_proc_RETURN	PROTOARGS((Node_id)),
	  g_proc_SEND	PROTOARGS((Node_id)),
	  g_proc_SET	PROTOARGS((Node_id)),
	  g_proc_SLEEP	PROTOARGS((Node_id)),
	  g_proc_SORT	PROTOARGS((Node_id)),
	  g_proc_STOP	PROTOARGS((Node_id)),
	  g_proc_STORE	PROTOARGS((Node_id)),
	  g_proc_UNLOCK	PROTOARGS((Node_id)),
	  g_proc_UPCASE	PROTOARGS((Node_id)),
	  g_proc_USING	PROTOARGS((Node_id)),
	  g_proc_WHILE	PROTOARGS((Node_id)),
	  g_proc_WRITE	PROTOARGS((Node_id)),
	  g_proc_WRITES	PROTOARGS((Node_id)),
	  g_proc_XCALL	PROTOARGS((Node_id)),
	  g_proc_XRETURN PROTOARGS((Node_id)),
	  g_proc_getput PROTOARGS((Node_id, char *, char *)),
	  g_proc_getputs PROTOARGS((Node_id, char *, char *)),
          g_proc_iochannel PROTOARGS((Node_id)),
	  g_proc_ioerror PROTOARGS((Node_id, Node_id, char *, char *));

static
void      argtype	PROTOARGS((int)),
	  move2arg	PROTOARGS((int, int)),
	  ref2arg	PROTOARGS((Node_id, int, int));
static
int       kw_2_args PROTOARGS((Node_id, int));

static
char     *extern_rtn_name PROTOARGS((char *)),
	 *to_c_filename	PROTOARGS((char *, char *));

/**
 *	Global "globals"
 */
char     *blkname,			/* Name of the routine/main	*/
          blkname_buffer[BUFSIZ];

/**
 *	Local "globals"
 */
static
Node_id   return_type = NIL;		/* Return type of module	*/
static
int       formal_params = 0;		/* # of formal parameters	*/
static
FILE     *f  = (FILE *)NULL,		/* The output file descriptor	*/
         *fh = (FILE *)NULL;		/* The output file's header	*/
static
int       indent;			/* Current indent level		*/
static
int       gloop_uid = 0, loop_uid = -1;	/* Global/current loop uid	*/
static
struct					/* Active block descriptor	*/
  {					/* ----------------------------	*/
    char     *name;			/* Active block name		*/
    int       id;			/* Active block blockid		*/
  }       block[MAX_BLOCK_DEPTH];	/* Active blocks		*/
static
int       cblock = -1;			/* No block active		*/
static
char      ver[20];			/* Version label		*/

/**
 *	Walk the net generating code to the output file.
 */
int
generate()						/* Function	*/
{
  if ( ! _parse.out )			/* User didn't specify out file	*/
    _parse.out = to_c_filename(_parse.file, "c");
  _parse.hdr = to_c_filename(_parse.out, "h");
  printf("generate code for file: %s\n", _parse.out);
#ifdef	GENERATE_H_FILE
  printf("              & header: %s\n", _parse.hdr);
#endif/*GENERATE_H_FILE*/

  g_open_file();			/* Open the *.c file		*/
  g_header();				/* Put the cdbl header		*/
  g_data_defs();			/* Generate data definitions	*/
  g_proc();				/* Generate procedural code	*/
  g_close_file();			/* Close the *.c file		*/

} /* generate */

/**
 *	Generate a reference (whole / [pseudo] array / substring)
 *
 *	Ok.  Some explanation.  g_proc_mkargs can call expr, which can
 *	call genref, etc, etc.  So, we cache a starting point above the
 *	__arg[]s reserved for parameter passing.  When we're done, we
 *	return the genref'd item in __an_arg.
 */
void
genref(spec)						/* Function	*/
  Node_id   spec;
{
  static
  int       narg = MAX_CALL_ARGS;
  int       my_narg_start;

  if (narg >= (MAX_CALL_ARGS + MAX_TMP_ARGS))
    c_error("increase MAX_TMP_ARGS, currently %d", MAX_TMP_ARGS);
  my_narg_start = narg;			/* "Top of Stack" so to speak	*/
  g_proc_mkargs(&narg, spec);
  if ((narg - my_narg_start) != 1)
    c_error("genref([%d]) for %d arguments narg=%d my_narg_start=%d?",
            spec, narg - my_narg_start, narg, my_narg_start);
  fprintf(f, "%*s__an_arg = __arg[%d];\n", INDENT, my_narg_start);
  narg = my_narg_start;			/* Restore to entry condition	*/
} /* genref */


/***
 *	LOCAL functions
 */

static
void
g_close_file()						/* Function	*/
{
  fprintf(f,  "\n\n");
  fprintf(f,  "/* End of %s : written by %s */\n", _parse.out, ver);
#ifdef	GENERATE_H_FILE
  fprintf(fh, "\n\n#endif/*_LOCAL_DBL_HEADER_H_*/\n");
  fprintf(fh, "\n");
  fprintf(fh, "/* End of %s : written by %s */\n", _parse.hdr, ver);
  fclose(fh);
#endif/*GENERATE_H_FILE*/
  fclose(f);
  if (_parse.flags)
    printf("closed file                   %s\n", _parse.out);
} /* g_close_file */

static
void
g_data_buffers(spec, dostruct, callid)			/* Function	*/
  Node_id   spec;
  int       dostruct;			/* 0=T__PARAMETER 1=T_RECORD	*/
  int       callid;
{
  static
  int       in_global = 0;
  static
  Node_id   lastspec = NIL,		/* If currently handling redef	*/
            initspec = NIL;		/* Spec that does init, if init	*/
  char     *bufnm, *alias;
  int       dounion, hasinit = 0, r;
  long      size;
  Node_id   n, d, t;

/** /printf("g_data_buffers: spec=%d\n", spec);
/***/
  { /* block */
    static
    Node_id   holdlastspec, holdinitspec;

    char     *xs;
    int       xt;
    ng(spec, &xt, &xs);
    if (xt == T_GLOBAL)			/* Bail out on global		*/
      {
	switch (callid)
	  {
	    case 0:			/* Last call, wrap up		*/
	      bufnm = find_string(spec, T_ID);
              fprintf(f, "%*s}       %s%s", (indent - 1) * 2, "",
	              bufnm, initspec ? "" : ";\n");
	      if (initspec)		/* Had one during global section*/
	        {
                  int       rec = 0;
		  fprintf(f, "\n= {\n");
		  initspec = rnn(spec, T__FIRST, NIL);
		  do			/* Generate initialized data*/
		    if ( ! rnn(initspec, T_O_COMMA, NIL) )
                      g_data_init(initspec, rec++, 1);
		  while (initspec = rnn(initspec, T__PRECEDES, NIL));
		  fprintf(f, "\n  };\n");
		}
	      indent  -= 2;
	      initspec = holdinitspec;
	      lastspec = holdlastspec;
	      in_global = 0;
	      break;
	    case 1:			/* First call, start struct	*/
	      holdinitspec = initspec;
	      holdlastspec = lastspec;
	      lastspec = NIL;		/* Only global can redef global	*/
	      initspec = NIL;
	      in_global = 1;
              fprintf(f, "%*sstruct\n", indent++ * 2, "");
              fprintf(f, "%*s{\n",      indent++ * 2, "");
	      break;
	    default:
	      c_error("%s: internal error: g_data_buffers callid=%d",
	              "g_data_buffers", callid);
	  }
        return;
      }
  } /* block */

  if (n = rnn(spec, T__REDEFINEDBY, NIL)) /* This is a main def		*/
    {
      Node_id   p;
      for (p = n;  n = rnn(spec, T__REDEFINEDBY, n);  p = n)
        /* Get to last redefines */ ;
      lastspec = p;			/* Last redef spec we'll see	*/
/** /printf("g_data_buffers: lastspec=%d\n", lastspec);
/***/
    }

  bufnm = find_string(spec, T_ID);	/* Name of buffer		*/
  size  = find_long(spec, T__SIZE_BUFFER);
  alias = NULL;

  if (n = rnn(spec, T__REDEFINES, NIL))	/* Is this an alias?		*/
    alias = find_string(n, T_ID);	/* Get name of alias		*/

  dounion = rnn(spec, T__REDEFINEDBY, NIL);
  if (dounion)
    {
      fprintf(f, "%*sunion\n", indent++ * 2, "");
      fprintf(f, "%*s{\n",     indent++ * 2, "");
    }

  if (dostruct)
    {
      fprintf(f, "%*sstruct\n", indent++ * 2, "");
      fprintf(f, "%*s{\n",      indent++ * 2, "");
    }

  d = spec;				/* Walk the definition		*/
  for (r = T__FIRST;  d = rnn(d, r, NIL);  r = T__PRECEDES)
    {
      t = rnn(d, T__TYPE, NIL);		/* Type descriptor for field	*/

      { /* block */			/* Skip aliases defined @@loc+off*/
	Node_id   a;
        if ((a = rnn(t, T__TYPE, NIL)) &&
	    (a = rnn(a, T__FIRST, NIL))
	   )
	  {
            int       xt, outsize;
            char     *xs, *fld;

	    fprintf(f, "#define %-15s ", fld = find_string(d, T_LABEL));
	    outsize = 9 + (((xt = strlen(fld)) > 15) ? xt : 15);

	    ng(a, &xt, &xs);
	    if (xt != T_O_AT)
	      c_error("g_data_buffers: %s internal alias expected @@", fld);

	    ng(a = rnn(a, T__PRECEDES, NIL), &xt, &xs);
	    if (xt != T_ID)
	      c_error("g_data_buffers: %s internal alias expected id", fld);
	    fprintf(f, "%s", xs);
	    outsize += strlen(xs);

	    a = rnn(a, T__PRECEDES, NIL);
	    if (a)			/* Have an offset too		*/
	      {
	        ng(a, &xt, &xs);
	        if (xt != T_O_ADD)
	          c_error("g_data_buffers: %s internal alias expected +", fld);

	        ng(a = rnn(a, T__PRECEDES, NIL), &xt, &xs);
		if (xt != T_NUMBER)
		  c_error("g_data_budders: %s internal alias expected number",
		          fld);
	        fprintf(f, "[%s]", xs);
		outsize += 2 + strlen(xs);

	        if (rnn(a, T__PRECEDES, NIL))
		  c_error("field alias for %s only allows id+offset", fld);
	      }
	    ng(rnn(t, T__TYPE, NIL), &xt, &xs);
            fprintf(f, "%*s/*   %-10.10s\t*/\n", (56 - outsize), "", xs);
            continue;			/* Is an alias - redefines space*/
	  }
      } /* block */

      /* if group */
      /*   ToDo */
      /* else */
      {
	int       ar;			/* Array relationship walker	*/
        int       xt;			/* For ng()			*/
        char     *xs;			/* For ng()			*/
	char      decl[200];		/* For output declaration	*/
        Node_id   a;			/* Array dimension descriptor	*/

	sprintf(decl, "char    %s", find_string(d, T_LABEL));
	if ((a = rnn(t, T_O_LBRACK, NIL)) ||
	    (a = rnn(t, T_O_LPAREN, NIL))
	   )
	  {
            ng(a, &xt, &xs);
	    strcat(decl, "[");		/* Add subscript		*/
	    strcat(decl, xs);
	    strcat(decl, "]");
	    for (ar = T__FIRST;  a = rnn(a, ar, NIL);  ar = T__PRECEDES)
              {
                ng(a, &xt, &xs);
	        strcat(decl, "[");	/* Add subscript		*/
	        strcat(decl, xs);
	        strcat(decl, "]");
              }
	  }
	strcat(decl, "[");		/* Add data alloc subscript	*/
	xs = find_string(t, T__SIZE_BUFFER);
	if ( ! ((dostruct == 0) && (strlen(xs) == 1) && (xs[0] == '0')))
	  strcat(decl, xs);
	strcat(decl, "];");
	ng(rnn(t, T__TYPE, NIL), &xt, &xs);
        fprintf(f, "%*s%-*s/* %-10.10s\t*/\n",
		indent * 2, "",	(56 - (indent * 2)), decl, xs
	       );
      }
      if (rnn(d, T__FIRST, NIL))	/* Note initializer		*/
        {
          hasinit = 1;
          if (_parse.flags && _parse.yydebug)
	    printf("g_data_buffers: %s hasinit\n", bufnm);
	  if ( ! alias)
	    initspec = spec;		/* Remember this spec		*/
	  else
	    c_warning("%s %s %s %s - ignored",
	            bufnm, "redefines",
		    find_string(rnn(spec, T__REDEFINES, NIL), T_ID),
		    "and cannot initialize data"
		   );
	}
    }

  if (dostruct)
    {
      fprintf(f, "%*s}       %s", --indent * 2, "", bufnm);
      --indent;
    }

  if (lastspec && (spec == lastspec))	/* This is the last redef spec	*/
    {
      fprintf(f, ";\n%*s}       %s_UNION", --indent * 2, "",
	      find_string(rnn(lastspec, T__REDEFINES, NIL), T_ID)
	     );
      --indent;
      lastspec = NIL;			/* Clear, done redefining	*/
    }

  if ( (! in_global) && (lastspec == NIL) && initspec)
    {					/* Set up initializer		*/
      g_data_init(initspec, 0, 0);	/* Generate initialized data	*/
      initspec = NIL;			/* Clear, its processed		*/
    }

  if (dostruct)
    fprintf(f, ";\n");
} /* g_data_buffers */

static
void
g_data_defs()						/* Function	*/
{
  indent = 0;				/* Indent level			*/
  if (_parse.flags)
    printf("writing data definitions to   %s\n", _parse.out);

  walk_divs(g_data_buffers, T_RECORD, 1);/* Walk 'data' divisions	*/
} /* g_data_defs */

static
void
g_data_init(initspec, rec, gbl)				/* Function	*/
  Node_id   initspec;
  int       rec;
{
  int       r;
  Node_id   d;
  char      initing_what[100], *cp;	/* For diagnostic purposes	*/
  char     *hold_filename = _parse.file;

  cp = find_string(initspec, T_ID);
  fprintf(f, "%s /* %s */\n", gbl ? "  " : "\n= {", cp);

  strcpy(initing_what, cp);		/* Set as 'filename' for diags	*/
  strcat(initing_what, ".");
  _parse.file = initing_what;

  if (_parse.flags && _parse.yydebug)
    printf("g_data_init: initspec=%d\n", initspec);

  d = initspec;				/* Walk the definition		*/
  for (r = T__FIRST;  d = rnn(d, r, NIL);  r = T__PRECEDES)
    {
      long      i, n;			/* # of elements		*/
      long      len;			/* Length of field		*/
      long      size;			/* Size of field (including [])	*/
      int       type;			/* 'A' or 'D'			*/
      char     *fldnm;			/* Name of field		*/

      Node_id   a,			/* Initializer walker		*/
                t;			/* Type descriptor		*/

      int       xt;			/* For ng()			*/
      char     *xs;			/* For ng()			*/

      fldnm = find_string(d, T_LABEL);	/* Name of field		*/
      t = rnn(d, T__TYPE, NIL);		/* Type descriptor for field	*/
      ng(rnn(t, T__TYPE, NIL), &xt, &xs);
      type = xs[0];			/* Get 1st char of type name	*/
      size = find_long(d, T__SIZE_BUFFER);
      len  = find_long(t, T__SIZE_BUFFER);
      n    = size / len;		/* Number of elements		*/

      if (_parse.flags && _parse.yydebug)
        printf("g_data_init: d=%d t=%d type=%c size=%ld len=%ld fldnm=%s\n",
			     d,   t,   type,   size,    len,    fldnm);

      					/* Change field name in diags	*/
      strcpy(strchr(initing_what, '.') + 1, fldnm);

      if ((a = rnn(t, T__TYPE, NIL)) &&
	  (a = rnn(a, T__FIRST, NIL))
	 )
	{
	  fprintf(f, "/*alias*/\t\t\t\t/* %-28s */\n", fldnm);
	  continue;
	}

      fprintf(f, "\t\t\t\t\t/* %-28s */\n", fldnm);

      i  = 0;
      if (a = rnn(d, T__FIRST, NIL))	/* Walk initializer		*/
        do
	  g_data_init_ele(a, (int)len, type);
	while ( (++i < n) && (a = rnn(a, T__PRECEDES, NIL)) );

      for (  ;  i < n;  ++i)		/* Fill remaining items		*/
	g_data_init_ele(NIL, (int)len, type);
    }

  if ( ! gbl )
    fprintf(f, "  }");
  _parse.file = hold_filename;		/* Restore file name		*/
} /* g_data_init */

static
void
g_data_init_ele(node, len, type)			/* Function	*/
  Node_id   node;
  int       len;
  int       type;
{
  int       bln;			/* Maintains strlen(buf)	*/
  char      buf[BUFSIZ];		/* Staging buffer for init val	*/

  if (len >= sizeof(buf))		/* Internal error, FAIL		*/
    {
      c_error("%s node=%d len=%d",
              "g_data_init_ele: FATAL - internal limit exceeded", node, len);
      exit( 1 );
    }

  strcpy(buf, "");			/* Initialize the buffer	*/
  bln = 0;
					/* Fetch user data to buf	*/
  { /* block */				/* ----------------------------	*/
    Node_id   d;
    int       xt, r;
    char     *xs;

/** /printf("g_data_init_ele: fetch via node=%d len=%ld type=%c\n",
/** /       node, len, type);
/***/
    r = T__FIRST;
    if (d = node)			/* We have an initializer	*/
      do				/* Fetch initializer to buf	*/
/** /{
/***/
        strcat(buf, (ng(d, &xt, &xs), bln += strlen(xs), xs));
/** /printf("g_data_init_ele: got %s \"%s\"\n", to_token(xt), xs);
/** /printf("  bln=%d buf=\"%s\"\n", bln, buf);
/** /}
/***/
      while ((bln < len) && (d = rnn(d, r, NIL), r = T__PRECEDES, d));
  } /* block */				/* Fetch user data to buf	*/

					/* Align data in buf as per type*/
  { /* block */				/* ----------------------------	*/
    register
    char     *dp, *sp;			/* src/dst pointers		*/
    register
    char      fill = '?';		/* ' ' or '0' based on type	*/

    if (_parse.flags && _parse.yydebug)
      printf("g_data_init_ele: align %c (%d):\"%s\"\n", type, bln, buf);

    if (bln > len)			/* Initializer too long		*/
      {
        c_warning("%s \"%*.*s\"",
                  "initializer too long, truncating to", len, len, buf
	         );
        buf[bln = len] = '\0';		/* Ensure truncated to len	*/
      }

    type = toupper(type);		/* Ensure uppercase char	*/
    switch (type)			/* Align			*/
      {
        default:
	  c_error("%s %c (yet)",
	          "FATAL - cannot initialize data field of type", type
	         );
	  exit( 1 );

        case 'A':
	  fill = ' ';			/* Fill to end of len with ' '	*/
	  for (dp = buf + bln;  bln < len;  ++bln)
	    *dp++ = fill;
	  *dp = '\0';			/* Terminate string		*/
	  break;

        case 'D':
	case 'F':
	case 'P':
	  fill = '0';
	  dp = buf + len;		/* End of target		*/
	  *dp-- = '\0';			/* Terminate target end		*/
	  sp = buf + bln - 1;		/* End of initializer data	*/
	  while (buf <= sp)		/* Until front of buffer is hit	*/
	    *dp-- = *sp--;		/*   copy data backwards (r->l)	*/
	  while (buf <= dp)		/* Until front of buffer is hit	*/
	    *dp-- = fill;		/*   set to default fill char	*/
	  break;
      }
    if (_parse.flags && _parse.yydebug)
      printf("g_data_init_ele: aligned %c (%d):\"%s\"\n",
             type, strlen(buf), buf);

  } /* block */				/* Align data in buf as per type*/

  					/* Dump the buffer to source	*/
  { /* block */				/* ----------------------------	*/
    int       i;
    for (i = 0;  i < len;  ++i)		/* Dump the buffer to source	*/
      {
        char      ch = buf[i];
        fprintf(f, "%s", (i && (i % 10) == 0) ? "\n"   : "" );
        fprintf(f, "%s", (     (i % 10) == 0) ? "    " : " ");
	if (isprint(ch))
          fprintf(f, "'%s%c',", strchr("'\\", ch) ? "\\" : "", ch);
	else
	  fprintf(f, "'\\%03o',", ch);
      }
    fprintf(f, "\n");
  } /* block */				/* Dump the buffer to source	*/

} /* g_data_init_ele */

static
void
g_header()						/* Function	*/
{
  FILE     *p;
  char      pwd[BUFSIZ], uname[BUFSIZ];
  int       i, sz;
  long      t = 0L;

  if (_parse.flags)
    printf("writing header information to %s\n", _parse.out);

  time( &t );				/* Get time stamp time		*/

  strcpy(pwd, "NOTE: unable to get working directory");
  if (p = popen("pwd", "r"))
    fgets(pwd, sizeof(pwd),     p), fclose(p), pwd[strlen(pwd) - 1]   = '\0';

  strcpy(uname, "NOTE: unable to 'uname -a'");
  if (p = popen("uname -a", "r"))
    fgets(uname, sizeof(uname), p), fclose(p), uname[strlen(uname)-1] = '\0';
  
  { /* block */				/* Get cdbl version		*/
    char     *bp, *ep;
    extern
    char     *version;			/* In cdbl.c			*/

    ep = strchr(bp = version, ' ');	/* Walk out to revision info	*/
    ep = strchr(bp = ep + 1,  ' ');
    ep = strchr(bp = ep + 1,  ' ');
    ep = strchr(bp = ep + 1,  ' ');
    ep = strchr(bp = ep + 1,  ' ');
    sprintf(ver, "cdbl %*.*s", ep - bp, ep - bp, bp);
  } /* block */

  fprintf(f, "/***\n");
  fprintf(f, " * $Source%c\n", '$');
  fprintf(f, " * $Revision%c $Date%c\n", '$', '$');
  fprintf(f, " *\n");
  fprintf(f, " * Created: %s", ctime(&t));
  fprintf(f, " * System:  %s\n", uname);
  fprintf(f, " *\n");
  fprintf(f, " * %s %s %s\n",
          "This program was created by", ver, "using the command line:");
  fprintf(f, " *\t$ cd %s", pwd);
#define MX_CMD_LINE	60
  sz = MX_CMD_LINE;
  for (i = 0;  i < _parse.argc;  ++i)
    {
      if (sz >= MX_CMD_LINE)
        fprintf(f, "%s\n *\t%s", i ? "\\" : "", i ? "    " : "$ "), sz = 0;
      fprintf(f, "%s ", _parse.argv[i]);
      sz += strlen(_parse.argv[i]);
    }
  fprintf(f, "\n");
#undef	MX_CMD_LINE
  /* Note: may need to "safe"-ify the strings if they contain close comment
   */
  fprintf(f, " *\n");
  fprintf(f, " * Environment variables (when created):\n");
  for (i = 0;  _parse.arge[i];  ++i)
    fprintf(f, " *\t%s\n", _parse.arge[i]);
  fprintf(f, " */\n\n");
#ifdef	GENERATE_H_FILE
  fprintf(f, "#include \"%s\"\n\n", _parse.hdr);

  fprintf(fh, "/***\n");
  fprintf(fh, " * $Locker%c $Header%c\n", '$', '$');
  fprintf(fh, " * $Source%c\n", '$');
  fprintf(fh, " *\n");
  fprintf(fh, " * For source file: %s\n", _parse.out);
  fprintf(fh, " * Created: %s", ctime(&t));
  fprintf(fh, " */\n\n");
  fprintf(fh, "#ifndef _LOCAL_DBL_HEADER_H_\n");
  fprintf(fh, "#define _LOCAL_DBL_HEADER_H_\n\n");
  fprintf(fh, "#include <stdio.h>\n");
  fprintf(fh, "#include <cdbl/cdbl_rt.h>\n\n");
#else /*GENERATE_H_FILE*/
  fprintf(f,  "#include <stdio.h>\n");
  fprintf(f,  "#include <cdbl/cdbl_rt.h>\n\n");
#endif/*GENERATE_H_FILE*/
} /* g_header */

static
void
g_open_file()						/* Function	*/
{
  if (_parse.flags)
    printf("opening output file           %s\n", _parse.out);
  if ( ! (f  = fopen(_parse.out, "w")) )/* Oops, can't open file??	*/
    perror(_parse.out), exit( 1 );
#ifdef	GENERATE_H_FILE
  if ( ! (fh = fopen(_parse.hdr, "w")) )/* Oops, can't open file??	*/
    perror(_parse.hdr), exit( 1 );
/**/setbuf(fh, NULL);
#endif/*GENERATE_H_FILE*/
/**/setbuf(f,  NULL);
} /* g_open_file */

static
void
g_proc()						/* Function	*/
{
  int       i, r;
  Node_id   d;

  indent = 0;				/* Indent level			*/

  if (_parse.flags)
    printf("writing procedural code to    %s\n", _parse.out);

  fprintf(f, "#ifndef MAX_CALL_STACK\n");
  fprintf(f, "#define MAX_CALL_STACK 100\n");
  fprintf(f, "#endif/*MAX_CALL_STACK*/\n\n");

  fprintf(f, "static\n");
  fprintf(f, "void\n");
  fprintf(f, "%s\n",
          "call_push(__call_return, __call_stack, lab)\t\t/* Function\t*/");
  fprintf(f, "  int       __call_return[];\n");
  fprintf(f, "  int      *__call_stack;\n");
  fprintf(f, "  int       lab;\n");
  fprintf(f, "{\n");
  fprintf(f, "  if (*__call_stack >= MAX_CALL_STACK)\n");
  fprintf(f, "    drt_FATAL(\"CALL stack overflow\");\n");
  fprintf(f, "  __call_return[++(*__call_stack)] = lab;\n");
  fprintf(f, "}\n");

  g_proc_decl();			/* Introduce the routine	*/

  fprintf(f, "{\n");
  fprintf(f, "  char     *__blkname = \"%s\";\n", blkname);
  fprintf(f, "#ifndef\tMAX_CALL_ARGS\n");
  fprintf(f, "#define MAX_CALL_ARGS %d\n", MAX_CALL_ARGS);
  fprintf(f, "#define MAX_TMP_ARGS  %d\n", MAX_TMP_ARGS);
  fprintf(f, "#endif/*MAX_CALL_ARGS*/\n");
  fprintf(f, "  DBLArg_t  __an_arg, __arg[MAX_CALL_ARGS+MAX_TMP_ARGS];\n");
  fprintf(f, "  IOS_t     __io_status;\n");
  fprintf(f, "  int       __iexpr, __isize, __ipos;\n");
  fprintf(f, "  int       __io_channel, __row, __col;\n");
  fprintf(f, "  long      __loffset;\n");
  fprintf(f, "  int       __n_dec;\n");
  fprintf(f, "  Llong     __nexpr, __nby, __nthru;\n");
  fprintf(f, "  Llong     ");
  for (i = 0;  i < MAX_NTEMP;  ++i)
    fprintf(f, "%s__n_%d", i ? ", " : "", i);
  fprintf(f, ";\n");
  fprintf(f, "  char      __string[BUFSIZ], __number[BUFSIZ], ");
  fprintf(f,             "__format[BUFSIZ], __xargbuf[BUFSIZ];\n");
  fprintf(f, "  int       __call_return[MAX_CALL_STACK], __call_stack = -1;\n");
  fprintf(f, "  char     *__prev_errortrap;\n");

  indent = 1;				/* Indent level			*/
  g_proc__call_return();		/* Generate call return dispatch*/
  g_proc__error_trap();			/* Generate error trap code	*/

  fprintf(f, "/* PROC %s*/\n", blkname);

  fprintf(f, "  __prev_errortrap = __errortrap;\n");
  fprintf(f, "  __errortrap      =  NULL;\n");

  g_proc_decl_toargs();			/* Convert formals to actuals	*/

  walk_divs(g_proc_code, T_PROC, 0);	/* Generate procedural code	*/

  fprintf(f, "  goto _call_return;\n");	/* In case it falls into here	*/
  fprintf(f, "} /* %s */\n", blkname);
} /* g_proc */

/**
 *	Generate a fatal error into the resulting C code so that it
 *	isn't accidentally compiled.  It is bogus.
 */
static
void
g_proc__FATAL(spec)					/* Function	*/
  Node_id   spec;
{
  fprintf(f, "!@@$ spec[%d] - FATAL ERROR - internal compiler error\n", spec);
} /* g_proc__FATAL */

static
void
g_proc__call_return()					/* Function	*/
{
  int       xt;
  Node_id   lab = NIL;
  char     *xs;
  fprintf(f, "\n%*sgoto _call_return_end;\n", INDENT);
  fprintf(f, "/**\n");
  fprintf(f, " * Call return.\n");
  fprintf(f, " *   This routine takes the top element of the call return\n");
  fprintf(f, " *   stack, and does a 'goto' to the return label, which is\n");
  fprintf(f, " *   was internally generated. If there is no active call,\n");
  fprintf(f, " *   (stack empty), then this routine is returned from (like\n");
  fprintf(f, " *   an XRETURN).\n");
  fprintf(f, " */\n");

  fprintf(f, "_call_return:\n");
  fprintf(f, "  if (__call_stack < 0) goto _call_return_return;\n");

  fprintf(f, "  switch ( __call_return[__call_stack--] )\n");
  fprintf(f, "    {\n");
  while (lab = rnn(_parse.div_base, T_RETURN, lab))
    {
      ng(lab, &xt, &xs);
      fprintf(f, "      case %s: goto _call_return_%s;\n", xs, xs);
    }
  fprintf(f, "    }\n");
  fprintf(f, "  /* Fall-thru to return */\n");
  fprintf(f, "_call_return_return:\n");
  fprintf(f, "\t\t\t\t\t/* Restore previous context\t*/\n");
  fprintf(f, "%*sdbl_linkage(NULL, (int *)NULL, (int *)NULL);\n", INDENT);
  fprintf(f, "%*s__errortrap = __prev_errortrap;\n", INDENT);
  if (return_type)			/* Is a subroutine/function	*/
    {
      int       xt;
      char     *xs;

      ng(return_type, &xt, &xs);
/**/if (_parse.flags) {
/**/printf("return_type=[%d] xt=%d(%s) xs=\"%s\"\n",
/**/       return_type, xt, to_token(xt), xs);
/**/}
/***/
      switch (xt)
        {
	  case T_SUBROUTINE:
	    fprintf(f, "%*sreturn /* from %s %s */ ;\n",
	            INDENT, to_token(xt), blkname);
	    break;
	  default:
            c_error("function return types not implemented, yet");
	}
    }
  else					/* Is a "main"			*/
    fprintf(f, "%*sdrt_EXIT(0) /* from main %s */;\n", INDENT, blkname);

  fprintf(f, "\n_call_return_end:\n\n");
} /* g_proc_call_return */

static
void
g_proc__error_trap()					/* Function	*/
{
  int       xt;
  Node_id   lab = NIL;
  char     *xs;

  fprintf(f, "\n%*sgoto _error_trap_end;\n", INDENT);
  fprintf(f, "/**\n");
  fprintf(f, " * Error trap.\n");
  fprintf(f, " *   If the contents of __errortrap do not match any of the\n");
  fprintf(f, " *   known labels, then a fatal error is generated.\n");
  fprintf(f, " *   The translator diagnoses what it has at compile time,\n");
  fprintf(f, " *   so the created source code (unmodified) should not have\n");
  fprintf(f, " *   any \"FATAL ERROR\" error traps.\n");
  fprintf(f, " */\n");

  fprintf(f, "_error_trap:\n");
  fprintf(f, "  __errortrap_trigger = 0;\n");
  fprintf(f, "  if ( ! __errortrap ) goto _error_trap_FATAL;\n");

  while (lab = rnn(_parse.div_base, T_LABEL, lab))
    {
      ng(lab, &xt, &xs);
      fprintf(f, "  if (strcmp(\"%s\",  __errortrap) == 0) goto %s%s;\n",
              xs, LABEL_JIMMIE, xs);
    }
  fprintf(f, "  /* Fall-thru to FATAL */\n");
  fprintf(f, "_error_trap_FATAL:\n");
  fprintf(f, "  if (__prev_errortrap)\n");
  fprintf(f, "    {\n");
  fprintf(f, "      __errortrap_trigger = 1;\n");
  fprintf(f, "      dbl_linkage(NULL, (int *)NULL, (int *)NULL);\n");
  fprintf(f, "      return;\t\t\t\t/* Let caller do error trap\t*/\n");
  fprintf(f, "    }\n");
  fprintf(f, "  drt_errortrap(__errortrap);\n");
  fprintf(f, "\n_error_trap_end:\n\n");
} /* g_proc__error_trap */

static
void
g_proc_code(spec, unused1, unused2)			/* Function	*/
  Node_id   spec;
  int       unused1;
  int       unused2;
{
  Node_id   d;
  int       r, xt;
  char     *xs;

  if ( ! spec )				/* Not expecting, just cautious	*/
    {
      c_error("g_proc_code: spec=[%d], unexpected.  Internal error.");
      g_proc__FATAL(spec);
      return;
    }

  d = spec;
  for (r = T__FIRST;  d = rnn(d, r, NIL);  r = T__PRECEDES)
    {
      if ( xs = find_string(d, T__FILE_LINENO) )
	{
	  char      line[10];
	  sprintf(line, "%d", atoi(strchr(xs, ':') + 1));
          fprintf(f, "  *__lineno = %s;%*s\t/*   [%5d]\t*/\n",
	          line, (39 - strlen(line)), "", d);
	  _parse.file = xs;
	}
      ng(d, &xt, &xs);
      if (xt != T_LABEL)		/* Labels get special processing*/
        fprintf(f, "\t\t\t\t\t\t\t/* %-12.12s\t*/\n", to_token(xt));
      switch (xt)
        {
	  default:
            fprintf(f, "%*s/* OP %s%s%s spec=%d*/\n",  INDENT,
                    to_token(xt), xs ? ":" : "", xs ? xs : "", d
	           );
	    fprintf(f, "%*s      ^^^^^^^ %s\n", INDENT,
	            "INVALID -- internal compiler error"
		   );
	    break;
	  case T_O_EQUAL:	g_proc_assign(d);		break;
	  case T_ACCEPT:	g_proc_ACCEPT(d);		break;
	  case T_BEGIN:		g_proc_BEGIN(d);		break;
	  case T_CALL:		g_proc_CALL(d);			break;
	  case T_CASE:		g_proc_CASE(d);			break;
	  case T_CLEAR:		g_proc_CLEAR(d);		break;
	  case T_CLOSE:		g_proc_CLOSE(d);		break;
	  case T_DECR:		g_proc_DECR(d);			break;
	  case T_DELETE:	g_proc_DELETE(d);		break;
	  case T_DETACH:	g_proc_DETACH(d);		break;
	  case T_DISPLAY:	g_proc_DISPLAY(d);		break;
	  case T_DO:		g_proc_DO(d);			break;
	  case T_END:		g_proc_END(d);			break;
	  case T_EXIT:		g_proc_EXIT(d);			break;
	  case T_EXITLOOP:	g_proc_EXITLOOP(d);		break;
/**/	  case T_FIND:		g_proc_FIND(d);			break;
	  case T_FLUSH:		g_proc_FLUSH(d);		break;
	  case T_FOR:		g_proc_FOR(d);			break;
	  case T_FORMS:		g_proc_FORMS(d);		break;
/**/	  case T_FRETURN:	g_proc_FRETURN(d);		break;
	  case T_GET:		g_proc_GET(d);			break;
	  case T_GETS:		g_proc_GETS(d);			break;
	  case T_GOTO:		g_proc_GOTO(d);			break;
	  case T_IF:		g_proc_IF(d);			break;
	  case T_INCR:		g_proc_INCR(d);			break;
	  case T_LABEL:		g_proc_LABEL(d);		break;
	  case T_LOCASE:	g_proc_LOCASE(d);		break;
/**/	  case T_LPQUE:		g_proc_LPQUE(d);		break;
	  case T_NEXTLOOP:	g_proc_NEXTLOOP(d);		break;
	  case T_NOP:		g_proc_NOP(d);			break;
	  case T_OFFERROR:	g_proc_OFFERROR(d);		break;
/**/	  case T_ONERROR:	g_proc_ONERROR(d);		break;
	  case T_OPEN:		g_proc_OPEN(d);			break;
	  case T_PUT:		g_proc_PUT(d);			break;
	  case T_PUTS:		g_proc_PUTS(d);			break;
	  case T_READ:		g_proc_READ(d);			break;
	  case T_READS:		g_proc_READS(d);		break;
/**/	  case T_RECV:		g_proc_RECV(d);			break;
	  case T_REPEAT:	g_proc_REPEAT(d);		break;
	  case T_RETURN:	g_proc_RETURN(d);		break;
/**/	  case T_SEND:		g_proc_SEND(d);			break;
/**/	  case T_SET:		g_proc_SET(d);			break;
	  case T_SLEEP:		g_proc_SLEEP(d);		break;
/**/	  case T_SORT:		g_proc_SORT(d);			break;
	  case T_STOP:		g_proc_STOP(d);			break;
	  case T_STORE:		g_proc_STORE(d);		break;
	  case T_UNLOCK:	g_proc_UNLOCK(d);		break;
	  case T_UPCASE:	g_proc_UPCASE(d);		break;
/**/	  case T_USING:		g_proc_USING(d);		break;
	  case T_WHILE:		g_proc_WHILE(d);		break;
	  case T_WRITE:		g_proc_WRITE(d);		break;
	  case T_WRITES:	g_proc_WRITES(d);		break;
	  case T_XCALL:		g_proc_XCALL(d);		break;
	  case T_XRETURN:	g_proc_XRETURN(d);		break;
        }
    }
} /* g_proc_code */

static
void
g_proc_decl()						/* Function	*/
{
  int       r, xt;
  char     *xs;
  Node_id   d;

  fprintf(f, "\n\n/* %s%s\t*/\n",
             "----------------------------------",
	     "----------------------------------"
         );
  fprintf(f, "/* %s%s\t*/\n",
             "   Note: The #line directives point",
	     " to the \"end\" of the statement."
	 );
  fprintf(f, "/* %s%s\t*/\n\n",
             "----------------------------------",
	     "----------------------------------"
         );
					/* Is this a function?		*/
  if (d = return_type = rnn(_parse.tree, T__TYPE, NIL))
    {					/* Function			*/
      ng(d, &xt, &blkname);
      strcpy(blkname_buffer, extern_rtn_name(blkname));
      blkname = blkname_buffer;
      g_proc_decl_init(0);		/* "Subr" flavor		*/
      fprintf(f, "int\t\t\t\t\t\t\t/* %s\t*/\n", to_token(xt));
    }
  else
    {
      blkname = CDBL_MAIN;
      g_proc_decl_init(1);		/* "Main" flavor		*/
      fprintf(f, "void\t\t\t\t\t\t\t/* PROGRAM\t*/\n");
    }
  fprintf(f, "%s(", blkname);		/* Generate formal param list	*/
  indent = strlen(blkname) + 2;		/* Indent interpreted 1:1	*/
  formal_params = 0;
  walk_divs(g_proc_decl_params, T__PARAMETER, 0);
  fprintf(f, "\n%*s)\n", indent - 2, "");

  					/* Generate formal param decls	*/
  indent = 1;				/* Indent level (interp 1:2)	*/
  walk_divs(g_data_buffers, T__PARAMETER, 0);

  sym_save_proc_decl();			/* Save proc decl in perm symtab*/
} /* g_proc_decl */

static
void
g_proc_decl_init(is_main)				/* Function	*/
  int       is_main;
{
  fprintf(f, "%s", is_main ? "" : "extern\n");
  fprintf(f, "int       __argc;\t\t\t/* Main's argc\t\t\t*/\n");
  fprintf(f, "%s", is_main ? "" : "extern\n");
  fprintf(f, "char    **__argv;\t\t\t/*   \"    argv\t\t\t*/\n");
  fprintf(f, "%s", is_main ? "" : "extern\n");
  fprintf(f, "char    **__arge;\t\t\t/*   \"    arge\t\t\t*/\n");
  fprintf(f, "%s", is_main ? "" : "extern\n");
  fprintf(f, "int       __exit%s;\t\t\t/* For main's return\t\t*/\n",
          is_main ? " = 0" : "");
  fprintf(f, "%s", is_main ? "" : "extern\n");
  fprintf(f, "int      *__lineno;\t\t\t/* Current source line\t\t*/\n");
  fprintf(f, "%s", is_main ? "" : "extern\n");
  fprintf(f, "char     *__errortrap%s;\n",        is_main ? " = NULL" : "");
  fprintf(f, "%s", is_main ? "" : "extern\n");
  fprintf(f, "int       __errortrap_trigger%s;\n", is_main ? " = 0" : "");
  fprintf(f, "\n");
  if (is_main)
    {
      fprintf(f, "void      %s\tPROTOARGS((void));\n", blkname);
      fprintf(f, "\n");
      fprintf(f, "int\n");
      fprintf(f, "main(argc, argv, arge)\t\t\t\t\t/* MAIN\t\t*/\n");
      fprintf(f, "  int       argc;\n");
      fprintf(f, "  char    **argv;\n");
      fprintf(f, "  char    **arge;\n");
      fprintf(f, "{\n");
      fprintf(f, "  __argc = argc;\n");
      fprintf(f, "  __argv = argv;\n");
      fprintf(f, "  __arge = arge;\n");
      fprintf(f, "  drt_INIT(argc, argv, arge);\n");
      fprintf(f, "  %s();\n", blkname);
      fprintf(f, "  return __exit;\n");
      fprintf(f, "} /* main */\n");
      fprintf(f, "\n");
    }
} /* g_proc_decl_init */

static
void
g_proc_decl_params(spec, unused1, unused2)		/* Function	*/
  Node_id   spec;
  int       unused1;			/* Currently unused		*/
  int       unused2;			/* Currently unused		*/
{
  int       r;
  long      size;
  Node_id   d;

  if (_parse.flags)
    printf("g_proc_decl_params: spec=%d\n", spec);

  d = spec;				/* Walk the definition		*/
  for (r = T__FIRST;  d = rnn(d, r, NIL);  r = T__PRECEDES)
    {
      fprintf(f, "%s\n%*s%s", (r == T__FIRST) ? "" : ",", indent, "",
		  find_string(d, T_LABEL)
	     );
      ++formal_params;			/* Bump # of formal parameters	*/
    }
} /* g_proc_decl_params */

static
void
g_proc_decl_toarg_fixup(spec, unused1, unused2)		/* Function	*/
  Node_id   spec;
  int       unused1;			/* Currently unused		*/
  int       unused2;			/* Currently unused		*/
{
  int       r;
  long      size;
  Node_id   d;

  if (_parse.flags)
    printf("g_proc_decl_toarg_fixup: spec=%d\n", spec);

  d = spec;				/* Walk the definition		*/
  for (r = T__FIRST;  d = rnn(d, r, NIL);  r = T__PRECEDES)
    {
      int       xt;
      Node_id   t;
      char     *type, *name;

      t = rnn(d, T__TYPE, NIL);		/* Type descriptor for field	*/
      ng(rnn(t, T__TYPE, NIL), &xt, &type);
      name = find_string(d, T_LABEL),
      fprintf(f, "%*sdbl_toarg(\"%s\", \"%s\", (void **)%s, %s, '%.1s');\n",
              INDENT, blkname, name, name, find_string(t, T__SIZE_BUFFER), type
	     );
    }
} /* g_proc_decl_toarg_fixup */

static
void
g_proc_decl_toargs()					/* Function	*/
{
  char     *file;
  int       len;
  file = _parse.file;
  len  = strchr(file, ':') - file;
  fprintf(f, "%*sdbl_linkage(\"%.*s\", __call_return, &__call_stack);\n",
          INDENT, len, file);
  if ( formal_params )			/* Have formals, so fix-up	*/
    walk_divs(g_proc_decl_toarg_fixup, T__PARAMETER, 0);
} /* g_proc_decl_toargs */

void							/* Function	*/
g_proc_mkarg_subr(spec, xargbufp, addr, size, type)
  Node_id   spec;
  int      *xargbufp;
  char     *addr;
  char     *size;
  char    **type;
{
  int       xt, rel;
  Node_id   d, n;
  char     *xs;

  if (_parse.flags)
    {
      printf("g_proc_mkarg_subr(spec=[%d]\n", spec);
      fprintf(f, "%*s/*parameter subr call spec=[%d]\n", INDENT, spec);
    }

  d = rnn(spec, T__SUBR, NIL);		/* Get parameter descriptors	*/
  ng(spec, &xt, &xs);
  if      (strcmp(xs, "$ERLIN")   == 0)
    {
/**/c_warning("use of $ERLEN, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $ERLEN spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$ERNUM")   == 0)
    {
/**/c_warning("use of $ERNUM, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $ERNUM spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$FALSE")   == 0)
    {
      strcpy(addr, "\"0\"");
      strcpy(size, "1");
      *type = "D1 $FALSE";
    }
  else if (strcmp(xs, "$LEN")     == 0)
    {
/**/c_warning("use of $LEN, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $LEN spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$LINE")    == 0)
    {
/**/c_warning("use of $LINE, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $LINE spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$PAINT")   == 0)
    {
/**/c_warning("use of $PAINT, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $PAINT spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$PTR")     == 0)
    {
/**/c_warning("use of $PTR, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $PTR spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$RDLEN")   == 0)
    {
/**/c_warning("use of $RDLEN, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $RDLEN spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$RDTRM")   == 0)
    {
/**/c_warning("use of $RDTRM, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $RDTRM spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$RND")     == 0)
    {
/**/c_warning("use of $RND, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $RND spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else if (strcmp(xs, "$SCR_ATT") == 0)
    {
      DAttr_t   dattr = 0;
      int       first = 1;

      if (_parse.flags)
        printf("$SCR_ATT d=[%d]\n", d);
      rel = T__FIRST;
      do 
        {
          n = rnn(d, T__EXPR, NIL);	/* First node of parameters	*/
	  if (first)			/* Latch in on list		*/
	    d = n, first = 0;
          if (_parse.flags)
            printf("  d=[%d], n=[%d]\n", d, n);
	  ng(n, &xt, &xs);		/* Get node item		*/
	  if ((xt != T_ID) && (xt != T_CLEAR))
Bad_SCR_ATT:
	    c_error("invalid $SCR_ATT option must be %s",
		    "BLINK, BOLD, CLEAR, RESTORE, REVERSE or SAVE"
		   );
	  /* Missing: UNDER GON GOFF */
	  else
	    {
	      if (_parse.flags)
	        printf(" xt=%d(%s) xs=%s\n", xt, to_token(xt), xs);
	      if      (strcmp(xs, "BLINK")   == 0)
	        dattr |= DBL_DA_BLINK;
	      else if (strcmp(xs, "BOLD")    == 0)
	        dattr |= DBL_DA_BOLD;
	      else if ((xt != T_CLEAR)       == 0)
	        dattr |= DBL_DA_CLEAR;
	      else if (strcmp(xs, "RESTORE") == 0)
	        dattr |= DBL_DA_RESTORE;
	      else if (strcmp(xs, "REV")     == 0)
	        dattr |= DBL_DA_REVERSE;
	      else if (strcmp(xs, "REVERSE") == 0)
	        dattr |= DBL_DA_REVERSE;
	      else if (strcmp(xs, "SAVE")    == 0)
	        dattr |= DBL_DA_SAVE;
	      else
	        goto Bad_SCR_ATT;
	    }
	}
      while (d = rnn(d, rel, NIL), rel = T__PRECEDES, d);
      fprintf(f, "\t\t\t\t\t/* $SCR_ATT of %ld = 0x%08lx */\n", dattr, dattr);
      sprintf(size, "%d", MAX_NUM_DIGITS);
      *type = "D18 $SCR_ATT";
      sprintf(addr, "\"%0*d\"", MAX_NUM_DIGITS, dattr);
      goto Return;
    }
  else if (strcmp(xs, "$SCR_CLR") == 0)
    {
      DAttr_t   dattr = 0;
      int       first = 1;

      if (_parse.flags)
        printf("$SCR_CLR d=[%d]\n", d);
      rel = T__FIRST;
      do 
        {
          n = rnn(d, T__EXPR, NIL);	/* First node of parameters	*/
	  if (first)			/* Latch in on list		*/
	    d = n, first = 0;
	  if (_parse.flags)
	    printf("  d=[%d], n=[%d]\n", d, n);
	  ng(n, &xt, &xs);		/* Get node item		*/
	  if (xt != T_ID)
Bad_SCR_CLR:
	    c_error("invalid $SCR_CLR option must be %s",
		    "EOL, EOS, LINE or SCREEN"
		   );
	  /* Missing: BOL BOS */
	  else
	    {
	      if (_parse.flags)
	        printf(" xt=%d(%s) xs=%s\n", xt, to_token(xt), xs);
	      if      (strcmp(xs, "EOL")     == 0)
	        dattr |= DBL_DA_CLREOL;
	      else if (strcmp(xs, "EOS")     == 0)
	        dattr |= DBL_DA_CLREOS;
	      else if (strcmp(xs, "LINE")    == 0)
	        dattr |= DBL_DA_CLRLINE;
	      else if (strcmp(xs, "SCREEN")  == 0)
	        dattr |= DBL_DA_CLRSCRN;
	      else
	        goto Bad_SCR_CLR;
	    }
	}
      while (d = rnn(d, rel, NIL), rel = T__PRECEDES, d);
      fprintf(f, "\t\t\t\t\t/* $SCR_CLR of %ld = 0x%08lx */\n", dattr, dattr);
      sprintf(size, "%d", MAX_NUM_DIGITS);
      *type = "D18 $SCR_CLR";
      sprintf(addr, "\"%0*d\"", MAX_NUM_DIGITS, dattr);
      goto Return;
    }
  /* Missing: $SCR_MOV(<row_chg>=-up/+down, <col_chg>=-left/+right) */
  else if (strcmp(xs, "$SCR_POS") == 0)
    {
      d = rnn(d, T__EXPR, NIL);		/* First node of parameters	*/
      if (_parse.flags)
        printf("$SCR_POS row d=[%d]\n", d);
      c_nexpr(f, indent, d);		/* Generate row expression	*/
      fprintf(f, "%*s__row = (int)__nexpr & 0xFF;\n", INDENT);
      if ((d = rnn(d, T__FIRST, NIL)) && (n = rnn(d, T__EXPR, NIL)))
        {
	  if (_parse.flags)
	    printf("$SCR_POS col d=[%d] n=[%d]\n", d, n);
	  c_nexpr(f, indent, n);	/* Generate column expression	*/
	  fprintf(f, "%*s__col = (int)__nexpr & 0xFF;\n", INDENT);
	  if (rnn(d, T__PRECEDES, NIL))
	    c_error("$SCR_POS only has two parameters: row, col");
	}
      else
        c_error("$SCR_POS missing column specification");
      fprintf(f, "%*ssprintf(&__xargbuf[%d], \"%%0%dd\", %s);\n", INDENT,
              *xargbufp, MAX_NUM_DIGITS, "(DBL_DA_POS | (__row << 8) | __col)"
	     );
      sprintf(addr, "&__xargbuf[%d]", *xargbufp);
      *type = "D18 $SCR_POS";
      sprintf(size, "%d", atoi(*type + 1));
      *xargbufp += atoi(size) + 1;	/* +1 for '\0'			*/
      if (*xargbufp >= BUFSIZ)
        c_error("%s (max size is %d)",
	        "too many actual parameter expressions for buffer",
		BUFSIZ);
      goto Return;
    }
  else if (strcmp(xs, "$TRUE")    == 0)
    {
      strcpy(addr, "\"1\"");
      strcpy(size, "1");
      *type = "D1 $TRUE";
    }
  else if (strcmp(xs, "$TRUNC")   == 0)
    {
/**/c_warning("use of $TRUNC, spec=[%d] d=[%d]", spec, d);
/**/fprintf(f, "/* $TRUNC spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
  else
    {
/**/c_error("cannot call function %s in actual parameter list yet", xs);
/**/fprintf(f, "/* function in actual list spec=[%d] d=[%d] */\n", spec, d);
/***/
    }
Return:
  ;	/* For ANSI's sake */
} /* g_proc_mkarg_subr */

/**
 * Note:
 *	Because g_proc_mkargs can get recursive (via c_nexpr -> genref ->
 *	g_proc_mkargs ..., and because we need to have temporary DBLArg_t
 *	entries, it is the responsibility of the caller to set 'nargs' to
 *	a starting point.  g_proc_mkargs may increment 'nargs' as it walks
 *	a list of arguments, so g_proc_mkargs does need it by reference.
 */
static
void
g_proc_mkargs(nargs, spec)				/* Function	*/
  int      *nargs;
  Node_id   spec;
{
  Node_id   d = spec;
  int       xargbufp = 0;		/* Current 'last' used (empty)	*/
  int       in_args;

  in_args = *nargs < MAX_CALL_ARGS;	/* Will be above if genref'ing	*/
  					/* If starting off below, then	*/
					/* assume we're in an argument	*/
					/* list to a function		*/
  do
    {
      static
      char      addr[BUFSIZ];
      char      size[BUFSIZ];
      char     *type, *flags;
      int       argtype;
      char     *argstring;

      if (*nargs >= (MAX_CALL_ARGS + MAX_TMP_ARGS))
        c_error("overflowing allocated args, %s",
	        "increase MAX_CALL_ARGS or MAX_TMP_ARGS");
/**/strcpy(addr, "-addr-");
/**/strcpy(size, "-1");
/**/type  = "-type-";
/**/flags = "-flags-";
/***/
      ng(d, &argtype, &argstring);
/**/if (_parse.flags)
/**/  printf("g_proc_mkargs: d=[%d] xt=%s(%d), xs=\"%s\"\n",
/**/         d, to_token(argtype), argtype, argstring);
/***/
SwitchAgain:
      switch (argtype)
        {
	  case T_O_COMMA:
	    flags = "ARG_ISEMPTY";
	    strcpy(size, "0");
	    type  = "A0";
	    sprintf(addr, "NULL");
	    break;
	  case T_NUMBER:
	    flags = "ARG_ISCONST";	/* MAX_NUM_DIGITS */
	    type  = strchr(argstring, '.') ? "D19" : "D18";
	    sprintf(size, "%d", atoi(type + 1));
	    sprintf(addr, "\"%.*s%s\"",	/* Make sure len of v is 'size'	*/
	            atoi(type + 1) - strlen(argstring), "000000000000000000",
		    argstring
		   );
	    break;
	  case T_STRING:
	    flags = "ARG_ISCONST";
	    sprintf(size, "%d", strlen(argstring));
	    type  = "A*";
	    { /* block */		/* Escape quotes in string	*/
              char      ch, *bp = argstring, *cp = addr;
	      *cp++ = '"';
	      while (ch = *bp++)
	        {
		  if (strchr("\\\"", ch))
		    *cp++ = '\\';
		  *cp++ = ch;
		}
	      *cp++ = '"';
	      *cp++ = '\0';
	    } /* block */
	    break;
	  case T_ID:
	    { /* block */
	      				/* HACK - was rnn(d, T__SUBR, n)*/
					/* but $RDLEN and $RDTRM have no*/
					/* actual lists, so have T__SUBR*/
					/* relation but no actuals.	*/

					/* I don't really like the rn	*/
					/* call with T__SUBR - 1 though	*/

					/* This is a subroutine call	*/
	      if (rn(d, T__SUBR - 1) == T__SUBR)
	        {
		  flags = "ARG_ISSUBR";
		  g_proc_mkarg_subr(d, &xargbufp, addr, size, &type);
	          break;
	        }
	      if (rn(d, T_CD_DEFINE - 1) == T_CD_DEFINE)
	        {
	          Node_id   t;
		  t = find_long(d, T_CD_DEFINE);
		  t = rnn(t, T_CD_DEFINE, NIL);
		  ng(t, &argtype, &argstring);
		  goto SwitchAgain;	/* Neat... huh...		*/
		}
	    } /* block */
	    flags = "ARG_ISVAR";
	    { /* block */
	      Node_id   t, tt, nd, nt, ele;
	      int       rel = T__FIRST, hasoffset = 0;

	      t    = atoi(find_string(d,  T__FIELD_OF));
	      tt   = rnn(t, T__TYPE, NIL);	/* Type descriptor	*/

	      strcpy(size, find_string(t, T__SIZE_BUFFER));
	      type = find_string(tt, T__TYPE);

	      if ((nd = rnn(d,T_O_LBRACK,NIL)) && (nt = rnn(tt,T_O_LBRACK,NIL))
	            ||
	          (nd = rnn(d,T_O_LPAREN,NIL)) && (nt = rnn(tt,T_O_LPAREN,NIL))
	         )
		{			/* Is (pseudo) array		*/
					/* Walk subscripts gen offset	*/
		  hasoffset = 1;
		  fprintf(f, "\t\t\t\t\t/* Offset into array\t\t*/\n");
	          fprintf(f, "%*s__loffset = 0;\n", INDENT);
		  do
		    {
		      			/* Have subscripted 'down' so	*/
					/* adjust size to this element	*/
		      strcpy(size, find_string(nt, T__SIZE_BUFFER));
/**
 * Note: the following goofiness is because currently real and pseudo arrays
 * are coded differently.  Pseudo array subscripts are held by a T__EXPR
 * whereas real subscripts are not.  So... if there is a T__EXPR at 'nd' 
 * dereference to it, else use nd (should really go back and make orthogonal).
 */
		      ele = rnn(nd, T__EXPR, NIL);
/**/ if (_parse.flags) {
/**/printf("mkargs: c_nexpr nd=[%d] ele=[%d]\n", nd, ele);
/**/fprintf(f, "/* mkargs: c_nexpr nd=[%d] ele=[%d] */\n", nd, ele);
/**/}
/***/
		      c_nexpr(f, indent, ele ? ele : nd);

		      fprintf(f, "%*s__loffset += ((long)__nexpr - 1) * %s;\n",
		              INDENT, size
			     );
		    }
		  while ((nd = rnn(nd, rel, NIL)) && (nt = rnn(nt, rel, NIL))
		         && (rel = T__PRECEDES, nd) /* "trick" see note */
		        );
/* Note: Not really much of a "trick", but telling you about it in case you
 *       don't really know C very well.
 * If there are more subscripts (nd && nt both non-zero), then the 2nd
 * subscript is off of the T__FIRST relationship, and 3rd-nth are off of
 * T__PRECEDES. So, the C "comma operator" is used to reestablish the
 * condition of the loop, after setting the relationship, after using the
 * relationship for this iteration...
 */
		}

/**/if (_parse.flags) {
/**/printf("mkargs: substr d=[%d] tt=[%d]\n", d, tt);
/**/fprintf(f, "/* mkargs: substr d=[%d] tt=[%d] */\n", d, tt);
/**/}
/***/
	      if ((nd=rnn(d, T_O_LPAREN, NIL)) && (!rnn(tt, T_O_LPAREN, NIL)))
	        {			/* Is substring reference	*/
		  int       xt;
	          Node_id   nl;
		  char     *xs;

		  fprintf(f, "\t\t\t\t\t/* Offset into substring\t*/\n");
	          strcpy(size, "__isize");
		  if ( ! hasoffset )
		    {
		      hasoffset = 1;
	              fprintf(f, "%*s__loffset = 0;\n", INDENT);
		    }
		  c_nexpr(f, indent, nl = rnn(nd, T__EXPR, NIL));
		  fprintf(f, "%*s__ipos = (int)__nexpr;\n", INDENT);
		  xt = 0;
		  if (nl = rnn(nl, T__FIRST, NIL))
		    ng(nl, &xt, &xs);
		  if      (xt == T_O_COMMA)
		    {
		      c_nexpr(f, indent, rnn(nl, T__EXPR, NIL));
		      fprintf(f, "%*s__isize = (int)__nexpr;\n", INDENT);
		    }
		  else if (xt == T_O_COLON)
		    {
		      c_nexpr(f, indent, rnn(nl, T__EXPR, NIL));
		      fprintf(f,"%*s__isize = (int)__nexpr - __ipos + 1;\n",
		              INDENT);
		    }
		  else
		    c_error("%s d=[%d] nd=[%d] nl=[%d] xt=%d:%s",
		            "g_proc_mkargs: unknown internal structure",
			    d, nd, nl, xt, to_token(xt));
	          fprintf(f, "%*s__loffset += __ipos - 1;\n", INDENT);
		}
	      { /* block */
		char     *ref, *fsize, *ftype;
		c_ref(d, &ref, &fsize, &ftype);
	        sprintf(addr, "((char *)&%.*s%s)",
	                     strlen(ref) - 1, ref,
			     hasoffset ? " + __loffset" : ""
		       );
	      } /* block */
	    } /* block */
	    break;
	  default:
	    flags = "ARG_ISEXPR";
	    { /* block */
	      Node_id   nd;

	      nd = d;
	      if ( ! nd )
		{
	          c_error("%s: unknown internal structure for %s d=[%d]",
		          "g_proc_mkargs", flags, d);
		  break;
		}
/**/fprintf(f, "/* NOTE: Assuming numeric argument.. Currently, cdbl\n");
/**/fprintf(f, " *       does NOT handle string expressions in the actual\n");
/**/fprintf(f, " *       parameter list of a function.\n");
/**/fprintf(f, " */\n");
/***/
	      c_nexpr(f, indent, nd);	/* Dump the expression		*/
	      sprintf(addr, "&__xargbuf[%d]", xargbufp);
	      type = "D18";
	      strcpy(size, type + 1);
	      xargbufp += atoi(size) + 1;/* +1 for '\0'			*/
	      if (xargbufp >= BUFSIZ)
	        c_error("%s (max size is %d)",
		        "too many actual parameter expressions for buffer",
			BUFSIZ);

              fprintf(f,
  "%*sdbl_mkarg(%s, __blkname, (void *)%s, %s, \"%s\", ARG_ISVAR);\n",
                      INDENT, "&__an_arg",
		      addr, size, type);
	      fprintf(f, "%*sdbl_putn(&__an_arg, __nexpr, __n_dec);\n",INDENT);
	    } /* block */
	    break;
	}
      fprintf(f,
  "%*sdbl_mkarg(&__arg[%d], __blkname, (void *)%s, %s, \"%s\", %s);\n",
              INDENT, *nargs,
	      addr, size, type, flags);
      ++*nargs;
      if (in_args && (*nargs > MAX_CALL_ARGS))
        c_error("more than %d call arguments (!??!), GET REAL!",
	        MAX_CALL_ARGS);
    }
  while (d = rnn(d, T__PRECEDES, NIL));
} /* g_proc_mkargs */

static
void
g_proc_stmts(spec)					/* Function	*/
  Node_id   spec;
{
  int       xt;
  char     *xs;

  ng(spec, &xt, &xs);			/* Get type of stmt		*/

  if (xt == T_BEGIN)
    {
      fprintf(f, "\t\t\t\t\t\t\t/* %-12.12s\t*/\n", to_token(xt));
      g_proc_BEGIN(spec);		/* Generate BEGIN-END block	*/
    }
  else
    {
      ++indent;
      g_proc_code(spec, 0, 0);		/* Generate code for statement	*/
      --indent;
    }
} /* g_proc_stmts */

static
void
g_proc_assign(spec)					/* Function	*/
  Node_id   spec;
{
  char     *ref, *size, *type;
  char      result_type, *align, *right;
  Node_id   e, fmt;

  c_ref(rnn(spec, T__LEFT, NIL), &ref, &size, &type);
  result_type = type[0];

  if (fmt = rnn(spec, T_O_COMMA, NIL))	/* Formatting info		*/
    {
      c_sexpr(f, indent, fmt);
      fprintf(f, "%*sstrcpy(__format, __string);\n", INDENT);
    }
  e = rnn(spec, T__RIGHT, NIL);		/* Expression			*/
  switch (result_type)
    {
      default:
        c_error("assignment to type %c unimplemented", result_type);
        /* fall-thru */
      case 'A':
        c_sexpr(f, indent, e);
	right = "__string";
	break;
      case 'D':
        c_nexpr(f, indent, e);
	right = "__number";
        fprintf(f,
  "%*sdbl_mkarg(%s, \"%s\", (void *)%s, %s, \"D%s\", ARG_ISVAR);\n",
                INDENT, "&__an_arg",
		blkname, right, size, size);
	fprintf(f, "%*sdbl_putn(&__an_arg, __nexpr, __n_dec);\n", INDENT);
	fprintf(f, "%*s%s[%s] = '\\0';\n", INDENT, right, size);
	break;
    }
  
  align = find_string(spec, T_ALIGN);	/* In event we have alignment	*/
  align = align ? align : "";

  					/* Re-establish ref info	*/
  genref(rnn(spec, T__LEFT, NIL));
  fprintf(f,
  	  fmt
           ? "%*sdbl_putsf(&__an_arg, \"%s\", %s, __format);\n"
           :  "%*sdbl_puts(&__an_arg, \"%s\", %s);\n",
	  INDENT, align, right);
} /* g_proc_assign */

static
void
g_proc_ACCEPT(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d, s;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
  if (d = rnn(s, T__FIRST, NIL))
    c_warning("not handling advanced ACCEPT options yet");
  if (d = rnn(s, T_O_COMMA, NIL))
    {
      genref(d);
      fprintf(f, "%*sdrt_accept(__io_channel, 1, &__an_arg);\n", INDENT);
    }
} /* g_proc_ACCEPT */

static
void
g_proc_BEGIN(spec)					/* Function	*/
  Node_id   spec;
{
  static
  int       beginid = 0;		/* Block # uid source		*/
  char     *lab;

  ++indent;
  lab = find_string(spec, T_LABEL);	/* Get label (if any)		*/

  if (++cblock < MAX_BLOCK_DEPTH)
    {
      block[cblock].name = lab;		/* Stash active block label	*/
      block[cblock].id   = ++beginid;	/* Assign an active block #	*/
    }
  else
    c_error("MAX_BLOCK_DEPTH of %d exceeded", MAX_BLOCK_DEPTH);

  fprintf(f, "%*s/* BEGIN BLOCK %d%s%s */\n", INDENT, block[cblock].id,
	  block[cblock].name ? " - " : "",
	  block[cblock].name ? block[cblock].name : ""
         );

  g_proc_code(spec, 0, 0);		/* Generate code for block	*/

  if (block[cblock].name)		/* Post exit tag for "EXIT blk"s*/
    fprintf(f, "%s_exit: ;\n",      block[cblock].name);
    					/* Post exit tag for "EXIT"s	*/
  fprintf(f, "_block_%d_exit: ;\n", block[cblock].id);
  --cblock;				/* Remove from active context	*/
  --indent;
} /* g_proc_BEGIN */

static
void
g_proc_CALL(spec)					/* Function	*/
  Node_id   spec;
{
  int       xt;
  Node_id   d, r, ret, expr;
  int       __call = 0;
  char     *xs;

  d = rnn(spec, T__FIRST, NIL);
  ret = (Node_id)find_long(d, T_RETURN);
  fprintf(f, "%*scall_push(__call_return, &__call_stack, %d);\n", INDENT, ret);
  if (expr = rnn(d, T__EXPR, NIL))	/* Computed CALL		*/
    {
      c_nexpr(f, indent, expr);
      fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
      fprintf(f, "%*sswitch ( __iexpr )\n", INDENT);
      fprintf(f, "%*s  {\n", INDENT);
      d = rnn(d, T_ID, NIL);
      r = T__FIRST;
      do
        {
          ng(d, &xt, &xs);
          if ( ! lkupid(d, T_LABEL) )
            c_error("no label \"%s\" in program", xs);
          fprintf(f, "%*s    case %d: goto %s%s;\n",
                  INDENT, ++__call, LABEL_JIMMIE, xs);
        }
      while (d = rnn(d, r, NIL), r = T__PRECEDES, d);
      fprintf(f, "%*s  }\n", INDENT);
    }
  else
    fprintf(f, "%*sgoto %s%s;\n", INDENT, LABEL_JIMMIE, find_string(d, T_ID));
  fprintf(f, "_call_return_%d: ;\n", ret);
} /* g_proc_CALL */

static
void
g_proc_CASE(spec)					/* Function	*/
  Node_id   spec;
{
  static
  int       case_uid = 0;
  char      selector_type = '?';
  int       selector_size = 0;
  int       case_id;
  int       xt, r;
  Node_id   d, e;
  char     *xs;

  case_id = ++case_uid;

  d = rnn(spec, T__FIRST, NIL);

  e = rnn(d, T__EXPR, NIL);		/* Generate Selector to __string*/
  ng(e, &xt, &xs);
  if (xt == T_ID)			/* Decode based on type	of ref	*/
    {
      char     *ref, *size, *type;
      Node_id   t;

      c_ref(e, &ref, &size, &type);
      if (_parse.flags)
	printf(" selector ref=%s, size=%s, type=%s\n", ref, size, type);
      switch (type[0])
        {
	  default:
	    c_error("CASE <ref> of type \"%s\" - not implemented", xs);
	    break;
	  case 'A':			/* Is A<x> data, merely copy	*/
	    fprintf(f, "%*ssprintf(__string, \"%%-*.*s\", %s, %s, %.*s);\n",
	            INDENT, size, size, strlen(ref) - 1, ref);
	    selector_type = 'A';
	    selector_size = atoi(size);
	    break;
	  case 'D':
            fprintf(f,
  "%*sdbl_mkarg(%s, \"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
                    INDENT, "&__an_arg",
		    blkname, strlen(ref) - 1, ref, size, type);
	    fprintf(f, "%*s__iexpr = dbl_num(&__an_arg);\n", INDENT);
	    goto NumericSelector;
	    break;
	}
    }
  else					/* Decode as numeric result	*/
    {
      c_nexpr(f, indent, e);
      fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
NumericSelector:
      selector_type = 'D';
      selector_size = 5;
    }

  r = T__FIRST;
  e = rnn(d, T_CASE, NIL);		/* Generate cases		*/
  if (_parse.flags)
    printf("cases e=[%d]\n", e);
  for (r = T__FIRST;  e = rnn(e, r, NIL);  r = T__PRECEDES)
    {
      char     *ref, *size, *type;
      Node_id   c;

      if (_parse.flags)
	printf("case_element e=[%d]\n", e);
      c = rnn(e, T__LEFT, NIL);
      if (_parse.flags)
	printf("case_range [%d]\n", c);
      ng(c, &xt, &xs);
      if (_parse.flags)
	printf("  which is %s(%d) \"%s\"\n", to_token(xt), xt, xs);
      switch (xt)
        {
	  default:
	    c_error("case range element %s %s not handled", to_token(xt), xs);
	    break;
	  case T_ID:
            c_ref(c, &ref, &size, &type);
	    if (rnn(c, T_O_LPAREN, NIL))/* add substring stuff		*/
	      c_error("substring not implemented");
	    if (((selector_type == 'A') && (atoi(size) != selector_size)) ||
	        (type[0]    != selector_type)
	       )
	      c_error("CASE %.*s (%s) %s (%c%d) - %s",
	              strlen(ref) - 1, ref, type,
		      "not same type/size as selector",
		      selector_type, selector_size,
		      "will never match");
            fprintf(f, "%*s%sif%s (strncmp(%.*s, __string, %s) == 0)\n",
	            INDENT, r == T__FIRST ? "" : "else ",
		            r == T__FIRST ? "     " : "",
		    strlen(ref) - 1, ref, size);
	    break;
	  case T_NUMBER:
	    if (selector_type != 'D')
	      c_error("CASE %s, selector is string, not a number", xs);
	    if (rnn(c, T__FIRST, NIL))	/* Have a range			*/
	      {
	        fprintf(f, "%*s%sif%s (__iexpr >= %5d || __iexpr <= %5d)\n",
		        INDENT, r == T__FIRST ? "" : "else ",
			        r == T__FIRST ? "     " : "",
			atoi(xs), (int)find_long(c, T__FIRST)
		       );
	      }
	    else
	      fprintf(f, "%*s%sif%s (__iexpr == %5d)\n", INDENT,
	              r == T__FIRST ? "" : "else ",
		      r == T__FIRST ? "     " : "",
		      atoi(xs)
		     );
	    break;
	  case T_STRING:
	    if (selector_type != 'A')
	      c_error("CASE \"%s\", selector is numeric, not a string", xs);
	    if (strlen(xs) > selector_size)
	      c_error("CASE \"%s\" %s", xs,
		      "longer than selector - will never match");
	    else if (strlen(xs) != selector_size)
	      c_warning("CASE \"%s\" %s %d, padded on right", xs,
	                "is shorter than the selector of length",
			selector_size);
            fprintf(f, "%*s%sif%s (strcmp(\"%-*s\", __string) == 0)\n",
	            INDENT, r == T__FIRST ? "" : "else ",
		            r == T__FIRST ? "     " : "",
		    selector_size, xs);
	}
      ++indent;
        fprintf(f, "%*s{\n", INDENT);
          g_proc_stmts(rnn(e, T__RIGHT, NIL));
          fprintf(f, "%*s  goto _case_%d_exit;\n", INDENT, case_id);
        fprintf(f, "%*s}\n", INDENT);
      --indent;
    }
  if (e = rnn(d, T_ELSE, NIL))		/* We have an "exception"	*/
    {
      fprintf(f, "%*selse\n", INDENT);
      ++indent;
        fprintf(f, "%*s{\n", INDENT);
          g_proc_stmts(e);
          fprintf(f, "%*s  goto _case_%d_exit;\n", INDENT, case_id);
        fprintf(f, "%*s}\n", INDENT);
      --indent;
    }
  fprintf(f, "_case_%d_exit: ;\n", case_id);
} /* g_proc_CASE */

static
void
g_proc_CLEAR(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d, s;
  int       i, narg = 0;
  if (d = rnn(spec, T__FIRST, NIL))	/* Process parameter list	*/
    g_proc_mkargs(&narg, d);		/* Setup arguments		*/
  for (i = 0;  i < narg;  ++i)		/* Build clear calls for each	*/
    fprintf(f, "%*sdrt_clear(&__arg[%d]);\n", INDENT, i);
} /* g_proc_CLEAR */

static
void
g_proc_CLOSE(spec)					/* Function	*/
  Node_id   spec;
{
  int       r;
  Node_id   d;

  d = spec;
  for (r = T__FIRST;  d = rnn(d, r, NIL);  r = T__PRECEDES)
    {
      g_proc_iochannel(d);		/* Leave channel in __io_channel*/
      fprintf(f, "%*sdrt_close(__io_channel);\n", INDENT);
    }
} /* g_proc_CLOSE */

static
void
g_proc_DECR(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d;
  char     *ref, *size, *type;

  d    = rnn(spec, T__FIRST, NIL);
  c_ref(d, &ref, &size, &type);
  switch (type[0])			/* Ensure it's DECR-able	*/
    {
      default:
        c_error("cannot decrement non-number field %s", ref);
      case 'D':
      case 'F':
        break;
    }
  genref(d);
  fprintf(f, "%*sdrt_decr(&__an_arg);\n", INDENT);
} /* g_proc_DECR */

static
void
g_proc_DELETE(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   ioex, d, s;
  int       used = 0;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/

  ioex = rnn(s, T__FIRST, NIL);		/* IO exception label (if any)	*/

  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/

  if (d = rnn(s, T_O_COMMA, NIL))	/* Delete key specified		*/
    ref2arg(d, T__RT_RECID, used++);

  fprintf(f, "%*s__io_status = drt_delete(__io_channel, %d, __arg);\n",
          INDENT, used);
  g_proc_ioerror(ioex, NIL, "DELETE", "EOF,ERR,KEY");
} /* g_proc_DELETE */

static
void
g_proc_DETACH(spec)					/* Function	*/
  Node_id   spec;
{
  fprintf(f, "%*sdrt_detach();\n", INDENT);
} /* g_proc_DETACH */

static
void
g_proc_DISPLAY(spec)					/* Function	*/
  Node_id   spec;
{
  char     *ref, *size, *type;
  char      szbuf[10];
  int       r;
  Node_id   d, s;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
  else
    c_error("g_proc_DISPLAY: internal error - no channel spec");
  d = s;				/* Start at spec.T__FIRST	*/
  { /* block */
    int       i, narg = 0;
    char     *rtn = "drt_display";
    g_proc_mkargs(&narg, rnn(d, T__FIRST, NIL));
    fprintf(f, "%*s%s(__io_channel,\n", INDENT, rtn, find_string(s, T_ID));
    for (i = 0;  i < narg;  ++i)	/* Build parameter list		*/
      fprintf(f, "%*s%*s &__arg[%d],\n", INDENT, strlen(rtn), "", i);
    fprintf(f, "%*s%*s (DBLArg_t *)NULL\n", INDENT, strlen(rtn), "");
    fprintf(f, "%*s%*s);\n", INDENT, strlen(rtn), "");
  } /* block */
} /* g_proc_DISPLAY */

/**
 *	Note:	T_DO process is limited to <do_until>.  T_DO is
 *		used as a noise word in other productions.
 *	do_until
 *		: T_FOREVER stmt
 *		| stmt T_UNTIL expr
 */
static
void
g_proc_DO(spec)						/* Function	*/
  Node_id   spec;
{
  int       l_uid, s_uid;
  int       xt;
  Node_id   d, e;
  char     *xs;

  l_uid = gloop_uid++;			/* Cache loop_uid for instance	*/
  if (_parse.flags)
    printf("g_proc_DO(spec=%d) l_uid=%d\n", spec, l_uid);

  d = rnn(spec, T__FIRST, NIL);
  ng(d, &xt, &xs);			/* Get type of T_DO		*/
  switch (xt)
    {
      case T_FOREVER:
      case T_UNTIL:
	break;
      default:
	g_proc__FATAL(spec);
        c_error("g_proc_DO: internal error, spec=[%d] d=[%d] xt=%d:%s %s",
	        spec, d, xt, to_token(xt), xs ? xs : "");
    }

  ++indent;
  s_uid    = loop_uid;			/* Save current loop_uid	*/
  loop_uid = l_uid;			/* Push ours as current		*/

  fprintf(f, "loop_%04d_top: ; /* %s */\n", l_uid, to_token(xt) );

  g_proc_stmts(rnn(d, T__STMT, NIL));	/* Generate code for T__STMT	*/

  fprintf(f, "loop_%04d_bottom: ;\n", l_uid);
  if (e = rnn(d, T__EXPR, NIL))		/* Expand control expression	*/
    {
      c_nexpr(f, indent, e);		/* Generate expression result	*/
      fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
      fprintf(f, "%*sif ( __iexpr )\n", INDENT);
      fprintf(f, "%*s  goto loop_%04d_top;\n", INDENT, l_uid);
    }
  else					/* Forever			*/
    fprintf(f, "%*sgoto loop_%04d_top;\n", INDENT, l_uid);
  fprintf(f, "loop_%04d_exit: ;\n", l_uid);

  loop_uid = s_uid;			/* Restore previous as current	*/
  --indent;
} /* g_proc_DO */

static
void
g_proc_END(spec)					/* Function	*/
  Node_id   spec;
{
  if (cblock >= 0)			/* If not active is END of pgm	*/
    fprintf(f, "%*s/* END BLOCK %d%s%s */\n", INDENT, block[cblock].id,
	    block[cblock].name ? " - " : "",
	    block[cblock].name ? block[cblock].name : ""
           );
} /* g_proc_END */

static
void
g_proc_EXIT(spec)					/* Function	*/
  Node_id   spec;
{
  char     *lab;

  if (lab = find_string(spec, T__FIRST))/* Has a block label to EXIT	*/
    {
      int       i;
      for (i = 0;  i <= cblock; ++i)
        if (block[i].name && 		/* Block has a name		*/
	    (strcmp(lab, block[i].name) == 0)/* Found - block is active	*/
	   )
	  {
	    fprintf(f, "%*sgoto %s_exit;\n", INDENT, lab);
	    goto Return;
	  }
      { /* block */			/* ERROR if we get to here	*/
        int       xt;			/* Work at giving a reasonable	*/
	Node_id   d;			/*   diagnostic message		*/
	char     *xs;
	
	d = NIL;			/* Let's look for such a block	*/
	while (d = rnn(_parse.div_base, T_BEGIN, d))
	  {
	    ng(d, &xt, &xs);
	    if (strcmp(lab, xs) == 0)	/* At least named block exists	*/
	      {
                c_error("EXIT not in context of block %s", lab);
	        goto Return;
	      }
	  }
      } /* block */
      c_error("There is no block named %s for EXIT", lab);
    }
  else
    {
      if (cblock < 0)
        c_error("EXIT not in context of a BEGIN-END block");
      else
        fprintf(f, "%*sgoto _block_%d_exit;\n", INDENT, block[cblock].id);
    }
Return: ;
} /* g_proc_EXIT */

static
void
g_proc_EXITLOOP(spec)					/* Function	*/
  Node_id   spec;
{
  if (loop_uid < 0)
    c_error("EXITLOOP not inside a loop context");
  fprintf(f, "%*sgoto loop_%04d_exit;\n", INDENT, loop_uid);
} /* g_proc_EXITLOOP */

static
void
g_proc_FIND(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d, s;
  Node_id   ioex;
  int       used = 0;
/**/c_warning("g_proc_FIND(spec=%d)", spec);
/***/
  fprintf(f, "  /* g_proc_FIND(spec=%d) */\n", spec);
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/

  ioex = rnn(s, T__FIRST, NIL);		/* IO exception label (if any)	*/

  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/

  if (d = rnn(s, T_O_COMMA, NIL))	/* Get parameters		*/
    {
      ref2arg(d, T__RT_RECID, used++);
      used = kw_2_args(s, used);
    }
  fprintf(f, "%*s__io_status = drt_find(__io_channel, %d, __arg);\n",
          INDENT, used);
  g_proc_ioerror(ioex, NIL, "FIND", "EOF,ERR,KEY");
} /* g_proc_FIND */

static
void
g_proc_FLUSH(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d = rnn(spec, T__FIRST, NIL);

  genref(d);
  fprintf(f, "%*sdrt_flush(&__an_arg);\n", INDENT);
} /* g_proc_FLUSH */

static
void
g_proc_FOR(spec)					/* Function	*/
  Node_id   spec;
{
  int       l_uid, s_uid;
  Node_id   d, e;

  l_uid = gloop_uid++;			/* Cache loop_uid for instance	*/
  if (_parse.flags)
    printf("g_proc_FOR(spec=%d) l_uid=%d\n", spec, l_uid);

  d = rnn(spec, T__FIRST, NIL);

  fprintf(f, "%*s__nby = 0;\n", INDENT);
  fprintf(f, "%*sgoto loop_%04d_init;\n", INDENT, l_uid);

  fprintf(f, "loop_%04d_top: ;\n", l_uid);

  ++indent;
  s_uid    = loop_uid;			/* Save current loop_uid	*/
  loop_uid = l_uid;			/* Push ours as current		*/

  g_proc_stmts(rnn(d, T__STMT, NIL));	/* Generate code for T__STMT	*/

  loop_uid = s_uid;			/* Restore previous as current	*/
  --indent;

  fprintf(f, "loop_%04d_bottom: ;\n", l_uid);

  if (e = rnn(d, T_BY, NIL))		/* BY <expr>			*/
    {
      c_nexpr(f, indent, e);		/* Generate code for BY		*/
      fprintf(f, "%*__nby = __nexpr;\n", INDENT);
    }
  else
    fprintf(f, "%*__nby = 1;\n", INDENT);
  fprintf(f, "%*sgoto loop_%04d_incr;\n", INDENT, l_uid);

  					/* FOR <init>			*/
  fprintf(f, "loop_%04d_init:\n", l_uid);
  e = rnn(d, T_FROM, NIL);		/* <cvar> = FROM <expr>		*/
  c_nexpr(f, indent, e);		/* Generate code for FROM	*/
  genref(rnn(d, T__REF, NIL));
  fprintf(f, "%*sdbl_putn(&__an_arg, __nexpr, __n_dec);\n", INDENT);

  fprintf(f, "loop_%04d_incr:\n", l_uid);
  e = rnn(d, T_THRU, NIL);		/* THRU <expr>			*/
  c_nexpr(f, indent, e);		/* Generate code for THRU	*/
  fprintf(f, "%*s__nthru = __nexpr;\n", INDENT);
					/* Load,increment & store <cvar>*/
  genref(rnn(d, T__REF, NIL));
  fprintf(f, "%*s__nexpr = dbl_num(&__an_arg) + __nby;\n", INDENT);
  fprintf(f, "%*sdbl_putn(&__an_arg, __nexpr, __n_dec);\n", INDENT);

  fprintf(f, "%*s__iexpr = __nexpr <= __nthru;\n", INDENT);
  fprintf(f, "%*sif ( __iexpr )\n", INDENT);
  fprintf(f, "%*s  goto loop_%04d_top;\n", INDENT, l_uid);

  fprintf(f, "loop_%04d_exit: ;\n", l_uid);
} /* g_proc_FOR */

static
void
g_proc_FORMS(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d, s;
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
  d =  rnn(s, T_O_COMMA, NIL);
  ref2arg(d, T__RT_CTRL, 0);		/* Forms output control value	*/
  fprintf(f, "%*s__io_status = drt_forms(__io_channel, 1, __arg);\n", INDENT);
  g_proc_ioerror(NIL, NIL, "FORMS", "ERR,LONG");
} /* g_proc_FORMS */

static
void
g_proc_FRETURN(spec)					/* Function	*/
  Node_id   spec;
{
/**/c_warning("g_proc_FRETURN(spec=%d)", spec);
/***/
  fprintf(f, "  /* g_proc_FRETURN(spec=%d) */\n", spec);
} /* g_proc_FRETURN */

static
void
g_proc_GET(spec)					/* Function	*/
  Node_id   spec;
{
  g_proc_getput(spec, "get", "GET");
} /* g_proc_GET */

static
void
g_proc_GETS(spec)					/* Function	*/
  Node_id   spec;
{
  g_proc_getputs(spec, "gets", "GETS");
} /* g_proc_GETS */

static
void
g_proc_GOTO(spec)					/* Function	*/
  Node_id   spec;
{
  int       xt, r, __goto = 0;
  Node_id   d, lab, expr;
  char     *xs;

  d = rnn(spec, T__FIRST, NIL);
  ng(d, &xt, &xs);			/* Get type of node		*/
  switch (xt)
    {
      case T_ID:
	if ( ! lkupid(d, T_LABEL) )
	  c_error("no label \"%s\" in program", xs);
	fprintf(f, "%*sgoto %s%s;\n", INDENT, LABEL_JIMMIE, xs);
        break;
      case T_GOTO:
	c_nexpr(f, indent, rnn(d, T__EXPR, NIL));
	fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
	fprintf(f, "%*sswitch ( __iexpr )\n", INDENT);
	fprintf(f, "%*s  {\n", INDENT);
	d = rnn(d, T_O_LPAREN, NIL);
	r = T__FIRST;
	do
	  {
	    ng(d, &xt, &xs);
	    if ( ! lkupid(d, T_LABEL) )
	      c_error("no label \"%s\" in program", xs);
	    fprintf(f, "%*s    case %d: goto %s%s;\n",
	            INDENT, ++__goto, LABEL_JIMMIE, xs);
	  }
	while (d = rnn(d, r, NIL), r = T__PRECEDES, d);
	fprintf(f, "%*s  }\n", INDENT);
        break;
      default:
	g_proc__FATAL(spec);
        c_error("g_proc_GOTO: internal error, spec=[%d] d=[%d] xt=%d:%s %s",
	        spec, d, xt, to_token(xt), xs ? xs : "");
    }
} /* g_proc_GOTO */

static
void
g_proc_IF(spec)						/* Function	*/
  Node_id   spec;
{
  static
  int       if_uid = 0;			/* UID for if statements	*/
  int       xt, if_id, has_else;
  Node_id   d, e;
  char     *xs;

  d = rnn(spec, T__FIRST, NIL);

  if_id = ++if_uid;			/* Get uid for this IF		*/

  has_else = rnn(d, T_ELSE, NIL);

  c_nexpr(f, indent, rnn(d, T__EXPR, NIL));
  fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
  fprintf(f, "%*sif ( ! __iexpr )\n", INDENT);
  fprintf(f, "%*s  goto _if_%04d_%s;\n", INDENT, if_id,
          has_else ? "else" : "end");

  g_proc_stmts(rnn(d, T_THEN, NIL));	/* Generate code for T_THEN stmt*/

  if (has_else)
    fprintf(f,"%*sgoto _if_%04d_end;\n", INDENT, if_id);

  if (e = rnn(d, T_ELSE, NIL))		/* Get ELSE stmt node		*/
    {
      fprintf(f, "_if_%04d_else:\n", if_id);
      g_proc_stmts(e);			/* Generate code for T_ELSE stmt*/
    }
  fprintf(f, "_if_%04d_end: ;\n", if_id);
} /* g_proc_IF */

static
void
g_proc_INCR(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d;
  char     *ref, *size, *type;

  d    = rnn(spec, T__FIRST, NIL);
  c_ref(d, &ref, &size, &type);
  switch (type[0])			/* Ensure it's INCR-able	*/
    {
      default:
        c_error("cannot increment non-number field %s", ref);
      case 'D':
      case 'F':
        break;
    }
  genref(d);
  fprintf(f, "%*sdrt_incr(&__an_arg);\n", INDENT);
} /* g_proc_INCR */

static
void
g_proc_LABEL(spec)					/* Function	*/
  Node_id   spec;
{
  int       xt;
  Node_id   d;
  char     *label;
  ng(spec, &xt, &label);
  fprintf(f, "%s%s:%.*s/* LABEL\t*/\n", LABEL_JIMMIE, label,
	  (64 - strlen(label) - strlen(LABEL_JIMMIE) - 1) / 8,
	  "\t\t\t\t\t\t\t");
} /* g_proc_LABEL */

static
void
g_proc_LOCASE(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d;
  char     *ref, *size, *type;

  d    = rnn(spec, T__FIRST, NIL);
  c_ref(d, &ref, &size, &type);
  switch (type[0])			/* Ensure it's LOCASE-able	*/
    {
      default:
        break;
      case 'D':
      case 'F':
        c_warning("why LOCASE numeric field %s?", ref);
    }
  genref(d);
  fprintf(f, "%*sdrt_locase(&__an_arg);\n", INDENT);
} /* g_proc_LOCASE */

static
void
g_proc_LPQUE(spec)					/* Function	*/
  Node_id   spec;
{
/**/c_warning("g_proc_LPQUE(spec=%d)", spec);
/***/
  fprintf(f, "  /* g_proc_LPQUE(spec=%d) */\n", spec);
} /* g_proc_LPQUE */

static
void
g_proc_NEXTLOOP(spec)					/* Function	*/
  Node_id   spec;
{
  if (loop_uid < 0)
    c_error("NEXTLOOP not inside a loop context");
  fprintf(f, "%*sgoto loop_%04d_bottom;\n", INDENT, loop_uid);
} /* g_proc_NEXTLOOP */

static
void
g_proc_NOP(spec)					/* Function	*/
  Node_id   spec;
{
  fprintf(f, "%*s/* NOP */\n", INDENT);
} /* g_proc_NOP */

static
void
g_proc_OFFERROR(spec)					/* Function	*/
  Node_id   spec;
{
  fprintf(f, "%*s__errortrap = (char *)0;\n", INDENT);
} /* g_proc_OFFERROR */

static
void
g_proc_ONERROR(spec)					/* Function	*/
  Node_id   spec;
{
  char     *lab = find_string(spec, T__FIRST);
/**/c_warning("g_proc_ONERROR(spec=%d)", spec);
/***/
  if ( ! lkupid(rnn(spec, T__FIRST, NIL), T_LABEL) )
    c_error("undefined label \"%s\" used in ONERROR", lab);
  fprintf(f, "%*s__errortrap = \"%s\";\n", INDENT, lab);
} /* g_proc_ONERROR */

static
void
g_proc_OPEN(spec)					/* Function	*/
  Node_id   spec;
{
  int       xt;
  Node_id   d, e, s;
  Node_id   ioex;
  char     *xs;
  char      buf[BUFSIZ];
  int       used = 0;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/

  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/

  ioex = rnn(s, T__FIRST, NIL);		/* IO exception label (if any)	*/

  d = rnn(s, T_O_COLON, NIL);		/* Mode spec			*/
  ng(d, &xt, &xs);
  switch(xt)
    {
      default:
        c_error("g_proc_OPEN: internal error - mode xt=%s(%d) d=[%d]", 
	        to_token(xt), xt, d);
	break;
      case T_MODE:
        genref(rnn(d, T_O_COLON, NIL));
	break;
      case T_ID:
        {
	  int       xmt;
	  Node_id   sm;
          char     *xms;

          sprintf(buf, "%*s", 1, xs);
	  if      ((strcmp("SI",      xs) == 0) ||
	           (strcmp("SINPUT",  xs) == 0)
	          )
	    {
	      sprintf(buf, "I:I");
	      c_warning("Mode %s changed to %s", xs, buf);
	    }
	  else if ((strcmp("SU",      xs) == 0) ||
	           (strcmp("SUPDATE", xs) == 0)
		  )
	    {
	      sprintf(buf, "U:I");
	      c_warning("Mode %s changed to %s", xs, buf);
	    }
	  else if (sm = rnn(d, T_O_COLON, NIL))/* Have sub-mode?	*/
	    {
	      ng(sm, &xmt, &xms);
	      strcat(buf, ":");
	      strncat(buf, xms, 1);
	    }
	}
	fprintf(f,
  "%*sdbl_mkarg(%s, \"%s\", (void *)\"%s\", %d, \"A%d\", ARG_ISCONST);\n",
                INDENT, "&__an_arg",
		blkname, buf, strlen(buf), strlen(buf));
	break;
    }
  move2arg(T__RT_MODE, used++);		/* __arg[0] = MODE		*/
  ref2arg(rnn(s, T_ID, NIL), T__RT_FILENAME, used++);

  used = kw_2_args(s, used);		/* Build up rest of args	*/

  					/* Setup error trap		*/
  fprintf(f, "%*s__io_status = drt_open(__io_channel, %d, __arg);\n",
          INDENT, used);
  g_proc_ioerror(ioex, NIL, "OPEN", "ERR");
} /* g_proc_OPEN */

static
void
g_proc_PUT(spec)					/* Function	*/
  Node_id   spec;
{
  g_proc_getput(spec, "put", "PUT");
} /* g_proc_PUT */

static
void
g_proc_PUTS(spec)					/* Function	*/
  Node_id   spec;
{
  g_proc_getputs(spec, "puts", "PUTS");
} /* g_proc_PUTS */

static
void
g_proc_READ(spec)					/* Function	*/
  Node_id   spec;
{
  int       used = 0;
  Node_id   ioex, lab;
  Node_id   d, s;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
  if (d = rnn(s, T__REF, NIL))
    ref2arg(d, T__RT_DATA, used++);	/* Data address			*/

/* CAVEAT: Not handling all options at this point */
  if ((d = rnn(s, T_O_COMMA, NIL)) && (d = rnn(d, T__FIRST, NIL)))
    {
      int       xt, haverec = 0;
      Node_id   rd;			/* Read option descriptor	*/
      char     *xs;
/** /printf("READ: d=[%d]\n", d);
/***/
      do
        {
	  rd = rnn(d, T__FIRST, NIL);
	  ng(rd, &xt, &xs);
/** /printf("READ: xt=%d(%s) rnn(rd=[%d], T__EXPR, NIL)=%d PRECEDES=[%d]\n",
/** /       xt, to_token(xt), rd,
/** /       rnn(rd, T__EXPR, NIL), rnn(rd, T__PRECEDES, NIL)
/** /      );
/***/
	  if (xt == T_KRF)
	    ref2arg(rnn(rd, T__EXPR, NIL), T_KRF, used++);
	  else
	    ref2arg(rd, T__RT_RECID, used++);
	}
      while (d = rnn(d, T__PRECEDES, NIL));
    }

  lab = NIL;				/* Initially no label		*/
  if (ioex = d = rnn(s, T__FIRST, NIL))	/* IO Exception (if any)	*/
    do
      {
        int       xt;
	char     *xs;
	ng(d, &xt, &xs);
	switch (xt)
	  {
	    default: c_error("unknown relation: [%d] %d:%s %s",
	                     d, xt, to_token(xt), xs ? xs : "");
	      break;
	    case T_O_EQUAL:		/* I/O exception		*/
	      lab = rnn(d, T__RIGHT, NIL);
	      break;
	    case T_ID:
	      if ((strcmp(xs, "WAIT") == 0) && rnn(d, T__SUBR, NIL))
	        goto IsWait;
	      break;
	    case T_WAIT:
IsWait: ;
	  }
      }
    while (d = rnn(d, T__PRECEDES, NIL));
  fprintf(f, "%*s__io_status = drt_read(__io_channel, %d, __arg);\n",
          INDENT, used);
  g_proc_ioerror(ioex, lab, "READ", "EOF,ERR,KEY,LOCK,LONG");
} /* g_proc_READ */

static
void
g_proc_READS(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d, s, ioex, lab;
  int       used = 0;
/** /c_warning("g_proc_READS(spec=%d)", spec);
/***/
  fprintf(f, "  /* g_proc_READS(spec=%d) */\n", spec);

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/

  ioex = rnn(s, T__FIRST, NIL);		/* Error list "surrounding"	*/
  lab  = rnn(s, T_LABEL, NIL);		/* Error label (if any)		*/

  if (d = rnn(s, T__REF, NIL))		/* Generate reference and call	*/
    {
      ref2arg(d, T__RT_DATA, used++);
      if (d = rnn(s, T_O_COMMA, NIL))
        {
	  for (d = rnn(d, T__FIRST, NIL);  d;  d = rnn(d, T__PRECEDES, NIL))
	    {
	      char     *xs;
	      Node_id   e;
              int       xt, r;
	      ng(d, &xt, &xs);
	      switch (xt)
	        {
		  case T_REVERSE:	/* 'q' is -1 to dbl_num()	*/
		    fprintf(f, 
  "%*sdbl_mkarg(%s, \"%s\", (void *)\"%s\", %d, \"D%d\", ARG_ISCONST);\n",
                INDENT, "&__an_arg", blkname, "q", 1, 1);
		    break;
		  case T_DIRECTION:
		  case T_WAIT:
		    r = rn(d, T__NIL);
		    e = rnn(d, r, NIL);
		    genref(e);
		    break;
		  default:
		    c_error("g_proc_READS: xt=%d\n", to_token(xt));
		}
	      move2arg(xt, used++);
	    }
        }
      fprintf(f, "%*s__io_status = drt_reads(__io_channel, %d, __arg);\n",
              INDENT, used);
      g_proc_ioerror(ioex, lab, "READS", "ERR,EOF,KEY");
    }
  else
    c_error("g_proc_READS: internal error, no <ref> for READS");
} /* g_proc_READS */

static
void
g_proc_RECV(spec)					/* Function	*/
  Node_id   spec;
{
/**/c_warning("g_proc_RECV(spec=%d)", spec);
/***/
  fprintf(f, "  /* g_proc_RECV(spec=%d) */\n", spec);
} /* g_proc_RECV */

/**
 *	Note:	The REPEAT statement is coded wierd in the tree.  Since
 *		it is merely "REPEAT <stmt>", the normal extra layer isn't
 *		there.  Must have been coded early on, and I don't see any
 *		reason to change it, so...   Normally, would generate code
 *		via:
 *		  d = rnn(spec, T__FIRST,NIL);
 *		  g_proc_stmts(rnn(spec, T__STMT, NIL));
 *		but that is currently the case.  Live with it!
 */
static
void
g_proc_REPEAT(spec)					/* Function	*/
  Node_id   spec;
{
  int       l_uid, s_uid;

  l_uid = gloop_uid++;			/* Cache loop_uid for instance	*/
  if (_parse.flags)
    printf("g_proc_REPEAT(spec=%d) l_uid=%d\n", spec, l_uid);

  fprintf(f, "loop_%04d_top: ;\n", l_uid);

  ++indent;
  s_uid    = loop_uid;			/* Save current loop_uid	*/
  loop_uid = l_uid;			/* Push ours as current		*/

  g_proc_stmts(spec);			/* Generate code for stmt	*/

  loop_uid = s_uid;			/* Restore previous as current	*/
  --indent;

  fprintf(f, "loop_%04d_bottom: ;\n", l_uid);
  fprintf(f, "%*sgoto loop_%04d_top;\n", INDENT, l_uid);
  fprintf(f, "loop_%04d_exit: ;\n", l_uid);
} /* g_proc_REPEAT */

static
void
g_proc_RETURN(spec)					/* Function	*/
  Node_id   spec;
{
  fprintf(f, "%*sgoto _call_return;\n", INDENT);
} /* g_proc_RETURN */

static
void
g_proc_SEND(spec)					/* Function	*/
  Node_id   spec;
{
/**/c_warning("g_proc_SEND(spec=%d)", spec);
/***/
/* Reminder: T__REF may be a string, etc */
  fprintf(f, "  /* g_proc_SEND(spec=%d) */\n", spec);
} /* g_proc_SEND */

static
void
g_proc_SET(spec)					/* Function	*/
  Node_id   spec;
{
/**/c_warning("g_proc_SET(spec=%d)", spec);
/***/
  fprintf(f, "  /* g_proc_SET(spec=%d) */\n", spec);
} /* g_proc_SET */

static
void
g_proc_SORT(spec)					/* Function	*/
  Node_id   spec;
{
/**/c_warning("g_proc_SORT(spec=%d)", spec);
/***/
  fprintf(f, "  /* g_proc_SORT(spec=%d) */\n", spec);
} /* g_proc_SORT */

static
void
g_proc_SLEEP(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d;

  d = rnn(spec, T__FIRST, NIL);

  c_nexpr(f, indent, rnn(d, T__EXPR, NIL));
  fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
  fprintf(f, "%*ssleep(__iexpr);\n", INDENT);
} /* g_proc_SLEEP */

static
void
g_proc_STOP(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d;

  if (d = rnn(spec, T__FIRST, NIL))
    {
      genref(d);
      fprintf(f, "%*sdrt_stop(&__an_arg);\n", INDENT);
    }
  else
    fprintf(f, "%*sdrt_terminate();\n", INDENT);
} /* g_proc_STOP */

static
void
g_proc_STORE(spec)					/* Function	*/
  Node_id   spec;
{
  int       used = 0;
  Node_id   d, s;
  Node_id   ioex;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/

  ioex = rnn(s, T__FIRST, NIL);		/* IO exception if any		*/

  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/

  if (d = rnn(s, T_O_COMMA, NIL))
    ref2arg(d, T__RT_RECID, used++); 	/* Optional key specified	*/

  if (d = rnn(s, T__REF, NIL))		/* Generate reference and call	*/
    {
      ref2arg(d, T__RT_DATA, used++);
      fprintf(f, "%*s__io_status = drt_store(__io_channel, %d, __arg);\n",
              INDENT, used);
      g_proc_ioerror(ioex, NIL, "STORE", "ERR,KEY");
    }
  else
    c_error("g_proc_STORE: internal error, no <ref> for STORE");
} /* g_proc_STORE */

static
void
g_proc_UNLOCK(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d;

  d = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  g_proc_iochannel(d);			/* Leave channel in __io_channel*/
  fprintf(f, "%*sdrt_unlock(__io_channel);\n", INDENT);
} /* g_proc_UNLOCK */

static
void
g_proc_UPCASE(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d;
  char     *ref, *size, *type;

  d    = rnn(spec, T__FIRST, NIL);
  c_ref(d, &ref, &size, &type);
  switch (type[0])			/* Ensure it's UPCASE-able	*/
    {
      default:
        break;
      case 'D':
      case 'F':
        c_warning("why UPCASE numeric field %s?", ref);
    }
  genref(d);
  fprintf(f, "%*sdrt_upcase(&__an_arg);\n", INDENT);
} /* g_proc_UPCASE */

static
void
g_proc_USING(spec)					/* Function	*/
  Node_id   spec;
{
  static
  int       using_uid = 0;
  char      selector_type = '?';
  int       selector_size = 0;
  int       using_id;
  int       xt, r;
  Node_id   d, e;
  char     *xs;

/**/c_warning("g_proc_USING(spec=%d)", spec);
/***/
  fprintf(f, "  /* g_proc_USING(spec=%d) */\n", spec);
/**/return;
/***/

  using_id = ++using_uid;

  d = rnn(spec, T__FIRST, NIL);

  e = rnn(d, T__EXPR, NIL);		/* Generate Selector to __string*/
  ng(e, &xt, &xs);
  if (xt == T_ID)			/* Decode based on type	of ref	*/
    {
      char     *ref, *size, *type;
      Node_id   t;

      c_ref(e, &ref, &size, &type);
      if (_parse.flags)
	printf(" selector ref=%s, size=%s, type=%s\n", ref, size, type);
      switch (type[0])
        {
	  default:
	    c_error("CASE <ref> of type \"%s\" - not implemented", xs);
	    break;
	  case 'A':			/* Is A<x> data, merely copy	*/
	    fprintf(f, "%*ssprintf(__string, \"%%-*.*s\", %s, %s, %.*s);\n",
	            INDENT, size, size, strlen(ref) - 1, ref);
	    selector_type = 'A';
	    selector_size = atoi(size);
	    break;
	  case 'D':
            fprintf(f,
  "%*sdbl_mkarg(%s, \"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
                    INDENT, "&__an_arg",
		    blkname, strlen(ref) - 1, ref, size, type);
	    fprintf(f, "%*s__iexpr = dbl_num(&__an_arg);\n", INDENT);
	    goto NumericSelector;
	    break;
	}
    }
  else					/* Decode as numeric result	*/
    {
      c_nexpr(f, indent, e);
      fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
NumericSelector:
      selector_type = 'D';
      selector_size = 5;
    }

  r = T__FIRST;
  e = rnn(d, T_CASE, NIL);		/* Generate cases		*/
  if (_parse.flags)
    printf("using cases e=[%d]\n", e);
  for (r = T__FIRST;  e = rnn(e, r, NIL);  r = T__PRECEDES)
    {
      char     *ref, *size, *type;
      Node_id   c;

      if (_parse.flags)
	printf("using_selector e=[%d]\n", e);
      c = rnn(e, T__LEFT, NIL);
      if (_parse.flags)
	printf("using_expr [%d]\n", c);
      ng(c, &xt, &xs);
      if (_parse.flags)
	printf("  which is %s(%d) \"%s\"\n", to_token(xt), xt, xs);
      switch (xt)
        {
	  default:
	    c_error("case range element %s %s not handled", to_token(xt), xs);
	    break;
	  case T_ID:
            c_ref(c, &ref, &size, &type);
	    if (rnn(c, T_O_LPAREN, NIL))/* add substring stuff		*/
	      c_error("substring not implemented");
	    if (((selector_type == 'A') && (atoi(size) != selector_size)) ||
	        (type[0]    != selector_type)
	       )
	      c_error("CASE %.*s (%s) %s (%c%d) - %s",
	              strlen(ref) - 1, ref, type,
		      "not same type/size as selector",
		      selector_type, selector_size,
		      "will never match");
            fprintf(f, "%*s%sif%s (strncmp(%.*s, __string, %s) == 0)\n",
	            INDENT, r == T__FIRST ? "" : "else ",
		            r == T__FIRST ? "     " : "",
		    strlen(ref) - 1, ref, size);
	    break;
	  case T_NUMBER:
	    if (selector_type != 'D')
	      c_error("CASE %s, selector is string, not a number", xs);
	    if (rnn(c, T__FIRST, NIL))	/* Have a range			*/
	      {
	        fprintf(f, "%*s%sif%s (__iexpr >= %5d || __iexpr <= %5d)\n",
		        INDENT, r == T__FIRST ? "" : "else ",
			        r == T__FIRST ? "     " : "",
			atoi(xs), (int)find_long(c, T__FIRST)
		       );
	      }
	    else
	      fprintf(f, "%*s%sif%s (__iexpr == %5d)\n", INDENT,
	              r == T__FIRST ? "" : "else ",
		      r == T__FIRST ? "     " : "",
		      atoi(xs)
		     );
	    break;
	  case T_STRING:
	    if (selector_type != 'A')
	      c_error("CASE \"%s\", selector is numeric, not a string", xs);
	    if (strlen(xs) > selector_size)
	      c_error("CASE \"%s\" %s", xs,
		      "longer than selector - will never match");
	    else if (strlen(xs) != selector_size)
	      c_warning("CASE \"%s\" %s %d, padded on right", xs,
	                "is shorter than the selector of length",
			selector_size);
            fprintf(f, "%*s%sif%s (strcmp(\"%-*s\", __string) == 0)\n",
	            INDENT, r == T__FIRST ? "" : "else ",
		            r == T__FIRST ? "     " : "",
		    selector_size, xs);
	}
      ++indent;
        fprintf(f, "%*s{\n", INDENT);
          g_proc_stmts(rnn(e, T__RIGHT, NIL));
          fprintf(f, "%*s  goto _using_%d_exit;\n", INDENT, using_id);
        fprintf(f, "%*s}\n", INDENT);
      --indent;
    }
  if (e = rnn(d, T_ELSE, NIL))		/* We have an "exception"	*/
    {
      fprintf(f, "%*selse\n", INDENT);
      ++indent;
        fprintf(f, "%*s{\n", INDENT);
          g_proc_stmts(e);
          fprintf(f, "%*s  goto _using_%d_exit;\n", INDENT, using_id);
        fprintf(f, "%*s}\n", INDENT);
      --indent;
    }
  fprintf(f, "_using_%d_exit: ;\n", using_id);
} /* g_proc_USING */

static
void
g_proc_WHILE(spec)					/* Function	*/
  Node_id   spec;
{
  int       l_uid, s_uid;
  Node_id   d, e;

  l_uid = gloop_uid++;			/* Cache loop_uid for instance	*/
  if (_parse.flags)
    printf("g_proc_WHILE(spec=%d) l_uid=%d\n", spec, l_uid);

  fprintf(f, "%*sgoto loop_%04d_bottom;\n", INDENT, l_uid);
  fprintf(f, "loop_%04d_top: ;\n", l_uid);

  d = rnn(spec, T__FIRST, NIL);

  ++indent;
  s_uid    = loop_uid;			/* Save current loop_uid	*/
  loop_uid = l_uid;			/* Push ours as current		*/

  g_proc_stmts(rnn(d, T__STMT, NIL));	/* Generate code for T__STMT	*/

  loop_uid = s_uid;			/* Restore previous as current	*/
  --indent;

  fprintf(f, "loop_%04d_bottom: ;\n", l_uid);
  if (e = rnn(d, T__EXPR, NIL))		/* Expand control expression	*/
    {
      c_nexpr(f, indent, e);		/* Generate expression		*/
      fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
      fprintf(f, "%*sif ( __iexpr )\n", INDENT);
      fprintf(f, "%*s  goto loop_%04d_top;\n", INDENT, l_uid);
    }
  else
    {
      g_proc__FATAL(d);			/* No expression???		*/
      c_error("g_proc_WHILE: internal error, spec=[%d] d=[%d] no T__EXPR",
	        spec, d);
    }

  fprintf(f, "loop_%04d_exit: ;\n", l_uid);
} /* g_proc_WHILE */

static
void
g_proc_WRITE(spec)					/* Function	*/
  Node_id   spec;
{
  int       used = 0;
  Node_id   d, s;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
  if (d = rnn(s, T__REF, NIL))		/* Generate reference and call	*/
    {
      if (rnn(d, T__FIRST, NIL))
        c_warning("not handling advanced WRITE options yet");
      ref2arg(d, T__RT_DATA, used++);

      if (d = rnn(s, T_O_COMMA, NIL))	/* Has recid			*/
	ref2arg(rnn(d, T__FIRST, NIL), T__RT_RECID, used++);

      fprintf(f, "%*s__io_status = drt_write(__io_channel, %d, __arg);\n",
              INDENT, used);
      g_proc_ioerror(NIL, NIL, "WRITE", "ERR");
    }
  else
    c_error("g_proc_WRITE: internal error, no <ref> for WRITE");
} /* g_proc_WRITE */

static
void
g_proc_WRITES(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d, s;
  int       used = 0;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
  if (d = rnn(s, T__REF, NIL))		/* Generate reference and call	*/
    {
      if (rnn(s, T_O_LESS, NIL))
        c_warning("not handling advanced WRITES options yet");
      ref2arg(d, T__RT_DATA, used++);
      fprintf(f, "%*s__io_status = drt_writes(__io_channel, %d, __arg);\n",
              INDENT, used);
      g_proc_ioerror(NIL, NIL, "WRITES", "ERR");
    }
  else
    c_error("g_proc_WRITES: internal error, no <ref> for WRITES");
} /* g_proc_WRITES */

static
void
g_proc_XCALL(spec)					/* Function	*/
  Node_id   spec;
{
  Node_id   d, s;
  int       used = 0;
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T__FIRST, NIL))	/* Process parameter list	*/
    g_proc_mkargs(&used, d);		/* Setup arguments		*/
  { /* block */				/* Call function		*/
    int       i;
    char     *rtn = extern_rtn_name(find_string(s, T_ID));
    fprintf(f, "%*s{\n", INDENT);
    ++indent;
    fprintf(f, "%*sextern void %s(int, DBLArg_t *);\n", INDENT, rtn);
    fprintf(f, "%*s%s(%d, __arg);\n", INDENT, rtn, used);
    fprintf(f, "%*sif (__errortrap_trigger)\n", INDENT);
    fprintf(f, "%*s  goto _error_trap;\n", INDENT);
    --indent;
    fprintf(f, "%*s}\n", INDENT);
  } /* block */
} /* g_proc_XCALL */

static
void
g_proc_XRETURN(spec)					/* Function	*/
  Node_id   spec;
{
  fprintf(f, "%*sreturn;\n", INDENT);
} /* g_proc_XRETURN */

static
void
g_proc_getput(spec, rtn, command)			/* Function	*/
  Node_id   spec;
  char     *rtn;
  char     *command;
{
  int       xt;
  int       used = 0;
  Node_id   d, s;
  Node_id   ioex, lab;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/

  ioex = rnn(s, T__FIRST, NIL);		/* IO exceptions (if any)	*/
  lab  = rnn(s, T_O_COMMA, NIL);	/* Keep io_error label		*/

					/* Setup reference to data	*/
  ref2arg(rnn(s, T__REF, NIL), T__RT_DATA, used++);
					/* Setup record number		*/
  ref2arg(rnn(s, T__EXPR, NIL), T__RT_RECID, used++);
  fprintf(f, "%*s__io_status = drt_%s(__io_channel, %d, __arg);\n",
          INDENT, rtn, used);
  g_proc_ioerror(ioex, lab, command, "EOF,ERR,LOCK,LONG");
} /* g_proc_getput */

static
void
g_proc_getputs(spec, rtn, command)			/* Function	*/
  Node_id   spec;
  char     *rtn;
  char     *command;
{
  int       xt;
  Node_id   d, s;
  Node_id   ioex;

  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/

  ioex = rnn(s, T__FIRST, NIL);		/* IO Exceptions (if any)	*/

					/* Setup reference to data	*/
  ref2arg(rnn(s, T__REF, NIL), T__RT_DATA, 0);
  fprintf(f, "%*s__io_status = drt_%s(__io_channel, 1, __arg);\n", INDENT,rtn);
  g_proc_ioerror(ioex, NIL, command, "EOF,ERR,LOCK,LONG");
} /* g_proc_getputs */

static
void
g_proc_iochannel(spec)					/* Function	*/
  Node_id   spec;
{
  c_nexpr(f, indent, spec);
  fprintf(f, "%*s__io_channel = (int)__nexpr;\n", INDENT);
} /* g_proc_iochannel */

static
void
g_proc_ioerror(spec, label, command, allow)		/* Function	*/
  Node_id   spec;
  Node_id   label;
  char     *command;
  char     *allow;
{
  Node_id   d, e;
  static				/* Match x_io_exception list	*/
  struct				/* Exception name to symbol map	*/
    {					/* ----------------------------	*/
      char     *name;			/* Language name for exception	*/
      char     *exception;		/* Exception name in source	*/
    }       ioex[] = {			/* ----------------------------	*/
		       { "EOF",	 "DBL_IOS_EOF"   },
		       { "ERR",	 "DBL_IOS_ERR"   },
		       { "KEY",	 "DBL_IOS_KEY"   },
		       { "LOCK", "DBL_IOS_LOCK"  },
		       { "LONG", "DBL_IOS_LONG"  },
		       { NULL  , "INVALID ENTRY" }
		     };
  char     *iolab[sizeof(ioex) / sizeof(ioex[0])];
  char     *xs;
  int       i, allowed, have, cond, xt;
  
  for (i = 0;  ioex[i].name;  ++i)	/* Clean out table		*/
    iolab[i] = NULL;

  allowed = 0;				/* Get allowed conditions	*/
  for (xs = allow;  xs && strlen(xs);  xs = strchr(xs, ','))
    {
      int       ln;
      char     *ep;
      if (xs[0] == ',')			/* Skip leading ','		*/
        ++xs;
      ln = strlen(xs);			/* Default to remaining chars	*/
      if (ep = strchr(xs, ','))
        ln = ep - xs;			/* Stop at end of name		*/
      for (i = 0;  ioex[i].name;  ++i)
        if (strncmp(xs, ioex[i].name, ln) == 0)
	  break;			/* Found exception name		*/
      if ( ! ioex[i].name )
	{
          c_error("%s: internal error, bad condition %.*s (\"%s\")",
	          "g_proc_ioerror", ln, xs, allow);
          return;
	}
      allowed |= 1 << i;		/* Add to set of allowed excptns*/
    }

  have = 0;

  if (label)				/* Label is for errors		*/
    {
      for (i = 0;  ioex[i].name;  ++i)
        if (strcmp("ERR", ioex[i].name) == 0)
	  break;
      if ( ! ioex[i].name)
        c_error("g_proc_ioerror: internal error, label: no ERR entry");
      ng(label, &xt, &xs);
      cond = 1 << i;
      if ( ! lkupid(label, T_LABEL))
        c_error("%s=%s unknown label", ioex[i].name, xs);
      else
	{
          iolab[i] = xs;		/* Save label			*/
          have |= cond;			/* Indicate we have condition	*/
	}
    }

/**
 * In the case of READ, etc, the T__FIRST may have other stuff in the list.
 * When this is true, then there is no T__LEFT, so we ignore the relation
 * here as it has been handled elsewhere.
 */
  if (d = spec)				/* Now parse the spec		*/
  do					/* ----------------------------	*/
    {
      if ( ! (e = rnn(d, T__LEFT, NIL)))/* Get condition		*/
        continue;			/*   (not a condition, ignore)	*/
      ng (e, &xt, &xs);
      for (i = 0;  ioex[i].name;  ++i)	/* Look up condition name	*/
        if (strcmp(ioex[i].name, xs) == 0)
	  break;
      if ( ! ioex[i].name)		/* Mismatch with x_io_exception	*/
        {
	  c_error("g_proc_ioerror: internal error, no entry for %s", xs);
	  return;
	}
      cond = 1 << i;			/* Flag for condition		*/

      if ( ! (allowed & cond) )
        c_error("can't have %s exception on %s", xs, command);
      else
        {
          e = rnn(d, T__RIGHT, NIL);	/* Get label for exception	*/
          ng(e, &xt, &xs);		/* Get name of label		*/
	  if ( have & cond )
            c_warning("already have %s=%s, label %s ignored",
	              ioex[i].name, iolab[i], xs);
          else
            {
	      if ( ! lkupid(e, T_LABEL) )
                c_error("%s=%s unknown label", ioex[i].name, xs);
	      else
		{
	          iolab[i] = xs;	/* Save label			*/
                  have |= cond;		/* Indicate we have condition	*/
		}
	    }
        }
    }
  while (d = rnn(d, T__PRECEDES, NIL));

  					/* Now generate the code	*/
					/* ----------------------------	*/
  fprintf(f, "%*sswitch (__io_status)\n", INDENT);
  fprintf(f, "%*s  {\n", INDENT);
  fprintf(f, "%*s    case DBL_IOS_OK:\n", INDENT);
  fprintf(f, "%*s      break;\n", INDENT);
  fprintf(f, "%*s    default:\n", INDENT);
  fprintf(f, "%*s      __errortrap = (char *)0;\n", INDENT);
  fprintf(f, "%*s      goto _error_trap;\n", INDENT);
  for (i = 0;  ioex[i].name;  ++i)
    if (iolab[i])
      {
	fprintf(f, "%*s    case %s:\n", INDENT, ioex[i].exception);
	fprintf(f, "%*s      __errortrap = \"%s\";\n", INDENT, iolab[i]);
	fprintf(f, "%*s      goto _error_trap;\n", INDENT);
      }
  fprintf(f, "%*s  }\n", INDENT);
} /* g_proc_ioerror */

static
void
argtype(token)						/* Function	*/
  int       token;
{
  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n",
          INDENT, token, to_token(token));
} /* argtype */

/**
 * For SUBROUTINE and XCALL, make names unique so variables don't collide.
 */
static
char *
extern_rtn_name(name)					/* Function	*/
  char     *name;
{
  static
  char      buf[BUFSIZ];
  sprintf(buf, "XCALL_FUNC(%s)", name ? name : "-<[NULL NAME?]>-");
  return buf;
} /* extern_rtn_name */

static
int
kw_2_args(s, used)					/* Function	*/
  Node_id   s;
  int       used;
{
  Node_id   d;
  if ((d = rnn(s, T_O_COMMA, NIL)) && (d = rnn(d, T__FIRST, NIL)))
    do
      {
	int       r, xt;
        Node_id   e;
	char     *xs;
        ng(d, &xt, &xs);
	if (r = rn(d, T__NIL))
	  {
	    e = rnn(d, r, NIL);		/* Get to what item references	*/
	    ref2arg(e, xt, used++);
	  }
        else
	  {
	    fprintf(f,			/* Build 'empty' argument	*/
  "%*sdbl_mkarg(&__an_arg, __blkname, (void *)%s, %s, \"%s\", %s);\n",
                    INDENT, "NULL", "0", "A0", "ARG_ISEMPTY"
	           );
	    move2arg(xt, used++);	/* Add type information		*/
	  }
      }
    while (d = rnn(d, T__PRECEDES, NIL));
  return used;
} /* kw_2_args */

static
void
move2arg(type, arg)					/* Function	*/
  int       type;
  int       arg;
{
  argtype(type);
  fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, arg);
} /* move2arg */

static
void
ref2arg(n, type, arg)					/* Function	*/
  Node_id   n;
  int       type;
  int       arg;
{
  genref(n);
  move2arg(type, arg);
} /* ref2arg */

/**
 *	Strip suffix, replacing with .<suffix>, with the following behaviors:
 *	  name.dbl -> name.c
 *	  x.dbl    -> x.c
 *	  name     -> name.c
 *	  .dbl     -> .dbl.c	<-- NOTE!  Made more sense than .c (?)
 */
static
char *
to_c_filename(name, suffix)				/* Function	*/
  char     *name;
  char     *suffix;
{
  char     *s;
  int       ln;
  					/* Find rightmost '.'		*/
  for (s = name + strlen(name) - 1;  (s > name) && (*s != '.');  --s)
    /* skip to rightmost '.' in name */ ;

  ln = s - name;			/* Length without suffix	*/
  ln = ln ? ln : strlen(name);		/* If had no suffix, keep all	*/

  					/* Allocate enuf for "name.c\0"	*/
  s = (char *) u_malloc(ln + strlen(suffix) + 2);
  sprintf(s, "%.*s.%s", ln, name, suffix);/* Create new name		*/
  return s;				/*   and return it		*/
} /* to_c_filename */


/* End of $Source: /home/ldl/dbl/cdbl/RCS/generate.c,v $ */
@


1.73
log
@1996-Mar-08 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.72 $ $Date: 1996/01/31 12:05:54 $
d1333 1
d1384 1
d1408 1
@


1.72
log
@1996-Jan-31 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.71 $ $Date: 1996/01/17 09:44:23 $
d3259 2
a3260 5
    fprintf(f, "%*sextern void %s();\n", INDENT, rtn);
    fprintf(f, "%*s%s(", INDENT, rtn);
    for (i = 0;  i < used;  ++i)	/* Build parameter list		*/
      fprintf(f, "%s&__arg[%d]", i ? ", " : "", i);
    fprintf(f, ");\n");
d3489 1
a3489 1
  sprintf(buf, "_X_%s", name ? name : "-<[NULL NAME?]>-");
@


1.71
log
@1996-Jan-17 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.70 $ $Date: 1995/11/20 18:53:00 $
d917 1
d1256 1
d1262 1
d1274 1
d1280 1
d1286 1
d1292 1
d1298 1
d1304 1
d1310 1
d1447 1
d1453 1
d1497 1
d2277 1
d2390 1
d2553 1
d2590 1
d2705 5
d2711 13
a2723 1
	ref2arg(d, T__RT_RECID, used++);
d2763 2
a2764 1
/**/c_warning("g_proc_READS(spec=%d)", spec);
d2818 1
d2873 1
d2884 1
d2894 1
d3007 1
d3010 1
@


1.70
log
@1995-Nov-20 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.69 $ $Date: 1995/11/11 11:15:10 $
d2075 4
a2078 3
  Node_id   d, s;
  int       cnt = 0;
  char      key[BUFSIZ];
d2080 1
a2080 1
  strcpy(key, "(DBLArg_t *)NULL");
a2081 1
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
d2084 7
a2090 7
  if (d = rnn(s, T_O_COMMA, NIL))
    {
      genref(d);
      strcpy(key, "&__an_arg");
      cnt = 1;
    }
  fprintf(f, "%*sdrt_delete(__io_channel, %d, %s);\n", INDENT, cnt, key);
a2274 7
#if 0
g_proc_argtype(token)
      genref(d);			/* The key			*/
      fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
              T__RT_RECID, to_token(T__RT_RECID));
      fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/
a2366 8
#if 0
g_proc_argtype(token)
  genref(d);				/* Forms output control value	*/
  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
          T__RT_CTRL, to_token(T__RT_CTRL));
  fprintf(f, "%*s__io_status = drt_forms(__io_channel, 1, &__an_arg);\n",
          INDENT);
#endif/*0*/
a2643 7
#if 0
g_proc_argtype(token)
  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
          T__RT_MODE, to_token(T__RT_MODE));
  fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/
					/* __arg[1] = FILE SPEC		*/
d2645 2
a2646 28
#if 0
g_proc_argtype(token)
  genref(rnn(s, T_ID, NIL));		/* __arg[1] = FILE SPEC		*/
  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
          T__RT_FILENAME, to_token(T__RT_FILENAME));
  fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/

  					/* Build up rest of args	*/
  used = kw_2_args(s, used);
#if 0
  if ((d = rnn(s, T_O_COMMA, NIL)) && (d = rnn(d, T__FIRST, NIL)))
    do
      {
	int       r;
        Node_id   e;
        ng(d, &xt, &xs);
	r = rn(d, T__NIL);
	e = rnn(d, r, NIL);		/* Get to what item references	*/
	ref2arg(e, xt, used++);
g_proc_argtype(token)
	genref(e);
	fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n",
	        INDENT, xt, to_token(xt));
	fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
      }
    while (d = rnn(d, T__PRECEDES, NIL));
#endif/*0*/
a2683 8
#if 0
g_proc_argtype(token)
  if (d = rnn(s, T__REF, NIL))
    genref(d);				/* Data address			*/
  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
          T__RT_DATA, to_token(T__RT_DATA));
  fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/
d2689 1
a2689 10
        {
	  ref2arg(d, T__RT_RECID, used++);
#if 0
g_proc_argtype(token)
	  genref(d);
          fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
                  T__RT_RECID, to_token(T__RT_RECID));
	  fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/
	}
a2741 7
#if 0
g_proc_argtype(token)
      genref(d);
      fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
              T__RT_DATA, to_token(T__RT_DATA));
      fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/
a2766 6
#if 0
g_proc_argtype(token)
	      fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n",
	              INDENT, xt, to_token(xt)); 
              fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/
d2906 1
a2906 10
    {					/* Optional key specified	*/
      ref2arg(d, T__RT_RECID, used++);
#if 0
g_proc_argtype(token)
      genref(d);
      fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
              T__RT_RECID, to_token(T__RT_RECID));
      fprintf(f, "%*s__arg[%d] = __an_arg; /* save key */\n", INDENT, used++);
#endif/*0*/
    }
a2910 7
#if 0
g_proc_argtype(token)
      genref(d);
      fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
              T__RT_DATA, to_token(T__RT_DATA));
      fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/
d3167 1
a3167 7
#if 0
g_proc_argtype(token)
      genref(d);
      fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
              T__RT_DATA, to_token(T__RT_DATA));
      fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, used++);
#endif/*0*/
d3169 2
a3170 10
        {
	  ref2arg(rnn(d, T__FIRST, NIL), T__RT_RECID, used++);
#if 0
g_proc_argtype(token)
	  genref(rnn(d, T__FIRST, NIL));
	  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
	          T__RT_RECID, to_token(T__RT_RECID));
	  fprintf(f, "%*s__arg[%d] =  __an_arg;\n", INDENT, used++);
#endif/*0*/
	}
a3196 8
#if 0
g_proc_argtype(token)
      genref(d);
      fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
              T__RT_DATA, to_token(T__RT_DATA));
      fprintf(f, "%*s__io_status = drt_writes(__io_channel, 1, &__an_arg);\n",
              INDENT);
#endif/*0*/
a3258 7
#if 0
g_proc_argtype(token)
  genref(rnn(s, T__REF, NIL));		/* Setup reference to data	*/
  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
          T__RT_DATA, to_token(T__RT_DATA));
  fprintf(f, "%*s__arg[0] = __an_arg;\n", INDENT);
#endif/*0*/
a3260 8
#if 0
g_proc_argtype(token)
  genref(rnn(s, T__EXPR, NIL));		/* Setup record number		*/
  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
          T__RT_RECID, to_token(T__RT_RECID));
  fprintf(f, "%*s__arg[1] = __an_arg;\n", INDENT);
  fprintf(f, "%*s__io_status = drt_%s(__io_channel, 2, __arg);\n", INDENT,rtn);
#endif/*0*/
a3284 7
#if 0
g_proc_argtype(token)
  genref(rnn(s, T__REF, NIL));		/* Setup reference to data	*/
  fprintf(f, "%*s__an_arg.flags |= %d /* %s */;\n", INDENT,
          T__RT_DATA, to_token(T__RT_DATA));
  fprintf(f, "%*s__arg[0]    =  __an_arg;\n");
#endif/*0*/
d3469 13
a3481 3
	r = rn(d, T__NIL);
	e = rnn(d, r, NIL);		/* Get to what item references	*/
	ref2arg(e, xt, used++);
@


1.69
log
@1995-Nov-11 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.68 $ $Date: 1995/11/03 09:20:05 $
d155 8
d2261 2
d2266 3
d2271 16
d2372 4
d2377 2
d2381 1
d2604 1
a2604 1
  int       nargs = 0;
d2658 3
a2660 1
  					/* __arg[0] = MODE		*/
d2663 6
a2668 2
  fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, nargs++);

d2672 2
a2673 1
  fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, nargs++);
d2676 2
d2686 2
d2691 1
a2691 1
	fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, nargs++);
d2694 1
d2698 1
a2698 1
          INDENT, nargs);
d2731 4
d2736 2
d2739 1
d2746 3
d2750 2
d2753 1
d2793 1
a2793 1
  int       narg = 0;
d2806 3
d2810 4
a2813 1
      fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, narg++);
d2838 3
d2843 2
a2844 1
              fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, narg++);
d2848 1
a2848 1
              INDENT, narg);
d2972 1
a2972 1
  int       used = 1;
d2974 1
d2977 3
d2982 1
d2985 3
d2989 4
a2992 2
      fprintf(f, "%*s__arg[1] = __an_arg; /* save key */\n", INDENT);
      used = 2;
d2994 1
d2997 3
d3001 7
a3007 2
      fprintf(f, "%*s__arg[0] = __an_arg;\n", INDENT);
      fprintf(f, "%*sdrt_store(__io_channel, %d, __arg);\n", INDENT, used);
d3250 1
d3260 3
d3264 17
a3280 2
      fprintf(f, "%*s__io_status = drt_write(__io_channel, 1, &__an_arg);\n",
              INDENT);
d3293 1
d3302 5
d3308 2
d3312 1
d3325 1
a3325 1
  int       narg = 0;
d3328 1
a3328 1
    g_proc_mkargs(&narg, d);		/* Setup arguments		*/
d3336 1
a3336 1
    for (i = 0;  i < narg;  ++i)	/* Build parameter list		*/
d3362 1
d3373 4
d3378 2
d3381 5
d3387 2
a3389 1

d3391 3
d3414 4
d3419 2
a3420 1

d3422 1
d3429 9
d3532 1
a3532 1
          e = rnn(d, T__RIGHT, NIL);/* Get label for exception	*/
d3572 2
a3573 2
g_proc_iochannel(spec)					/* Function	*/
  Node_id   spec;
d3575 3
a3577 3
  c_nexpr(f, indent, spec);
  fprintf(f, "%*s__io_channel = (int)__nexpr;\n", INDENT);
} /* g_proc_iochannel */
d3592 43
@


1.68
log
@1995-Nov-03 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.67 $ $Date: 1995/10/24 08:27:36 $
@


1.67
log
@1995-Oct-24 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.66 $ $Date: 1995/10/23 09:19:34 $
d362 46
d548 8
d557 1
d2623 3
a2625 1
  fprintf(f, "%*s__arg[0] = __an_arg;\n", INDENT);
d2628 3
a2630 1
  fprintf(f, "%*s__arg[1] = __an_arg;\n", INDENT);
d2632 1
a2632 1
  					/* Warn about args not handled	*/
d2636 2
d2639 6
a2644 1
        c_warning("not handling OPEN %s spec yet - ignored", to_token(xt));
d2649 2
a2650 1
  fprintf(f, "%*s__io_status = drt_open(__io_channel, 2, __arg);\n", INDENT);
d2731 2
a2732 1
  Node_id   d, s;
d2735 1
d2739 43
@


1.66
log
@1995-Oct-23 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.65 $ $Date: 1995/10/19 02:07:25 $
d1963 1
a1963 2
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T__FIRST, NIL))	/* Process parameter list	*/
d2129 5
a2133 4
  fprintf(f, "%*s/* END BLOCK %d%s%s */\n", INDENT, block[cblock].id,
	  block[cblock].name ? " - " : "",
	  block[cblock].name ? block[cblock].name : ""
         );
d2289 3
a2291 1
  fprintf(f, "%*sdrt_forms(__io_channel, &__an_arg);\n", INDENT);
d3058 3
a3060 1
      fprintf(f, "%*sdrt_write(__io_channel, 1, &__an_arg);\n", INDENT);
d3081 3
a3083 1
      fprintf(f, "%*sdrt_writes(__io_channel, 1, &__an_arg);\n", INDENT);
@


1.65
log
@1995-Oct-18 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.64 $ $Date: 1995/09/28 09:40:08 $
@


1.64
log
@1995-Sep-28 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.63 $ $Date: 1995/09/19 10:41:30 $
d27 1
d38 1
a38 1
 *  __n_0, __n_1, ...  long long   Numeric (cached) value
d40 3
a42 3
 *  __nby              long long   "FOR" 'step' value
 *  __nexpr            long long   Expression result (full precision)
 *  __nthru            long long   "FOR" ending value
d94 2
a95 3
          g_proc_mkarg_subr
	  		PROTOARGS((Node_id,int*,char*,char*,char*,char**)),
	  g_proc_mkargs	PROTOARGS((int *, char *, Node_id)),
d138 1
d231 1
a231 1
  g_proc_mkargs(&narg, blkname, spec);
d460 1
d515 1
d761 1
d772 2
a773 2
  fprintf(f, "  long long __nexpr, __nby, __nthru;\n");
  fprintf(f, "  long long ");
d987 2
a988 2
/**/	  case T_READ:		g_proc_READ(d);			break;
/**/	  case T_READS:		g_proc_READS(d);		break;
d993 1
d1002 2
a1003 2
/**/	  case T_WRITE:		g_proc_WRITE(d);		break;
/**/	  case T_WRITES:	g_proc_WRITES(d);		break;
d1169 1
a1169 1
g_proc_mkarg_subr(spec, xargbufp, caller, addr, size, type)
a1171 1
  char     *caller;
d1200 1
a1200 1
      strcpy(addr, "0");
d1366 1
a1366 1
      strcpy(addr, "1");
d1394 1
a1394 1
g_proc_mkargs(nargs, caller, spec)			/* Function	*/
a1395 1
  char     *caller;
d1476 1
a1476 1
		  g_proc_mkarg_subr(d, &xargbufp, caller, addr, size, &type);
d1587 1
a1587 1
	        sprintf(addr, "(char *)&%.*s%s",
d1622 1
a1622 1
  "%*sdbl_mkarg(%s, \"%s\", (void *)%s, %s, \"%s\", ARG_ISVAR);\n",
d1624 1
a1624 1
		      blkname, addr, size, type);
d1630 1
a1630 1
  "%*sdbl_mkarg(&__arg[%d], \"%s\", (void *)%s, %s, \"%s\", %s);\n",
d1632 1
a1632 1
	      caller, addr, size, type, flags);
d1965 1
a1965 1
    g_proc_mkargs(&narg, blkname, d);	/* Setup arguments		*/
d2058 1
a2058 1
    g_proc_mkargs(&narg, blkname, rnn(d, T__FIRST, NIL));
d2536 1
d2538 15
a2552 1
	  if (sm = rnn(d, T_O_COLON, NIL))/* Have sub-mode?		*/
d2556 1
a2556 1
	      strcat(buf, xms);
d2609 1
a2609 2
/**/c_warning("g_proc_READ(spec=%d)", spec);
  fprintf(f, "  /* g_proc_READ(spec=%d) */\n", spec);
d2615 1
a2615 1
  fprintf(f, "%*s__arg[%d] = __an_arg;\n", INDENT, ++used);
d2617 10
a2626 1
/**/if (rnn(s, T_O_COMMA, NIL)) c_warning("READ args not implemented yet");
d2736 9
d3092 1
a3092 1
    g_proc_mkargs(&narg, blkname, d);	/* Setup arguments		*/
@


1.63
log
@1995-Sep-19 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.62 $ $Date: 1995/09/11 10:27:11 $
d458 1
d460 6
a465 4
  fprintf(f, "%s /* %s */\n",
          gbl ? "  " : "\n= {",
	  find_string(initspec, T_ID)
	 );
d497 3
d618 1
a618 1
          fprintf(f, "'%s%c',", (ch == '\'') ? "\\" : "", ch);
d979 1
a979 1
	  case T_ONERROR:	g_proc_ONERROR(d);		break;
d1771 5
a1775 1
  Node_id   d, r;
d1777 24
a1800 4
  r = (Node_id)find_long(d, T_RETURN);
  fprintf(f, "%*scall_push(__call_return, &__call_stack, %d);\n", INDENT, r);
  fprintf(f, "%*sgoto %s%s;\n", INDENT, LABEL_JIMMIE, find_string(d, T_ID));
  fprintf(f, "_call_return_%d: ;\n", r);
d2492 1
d2767 1
a2767 1
      fprintf(f, "%*s__arg[0] = __an_arg;\n");
d2813 9
d2824 136
@


1.62
log
@1995-Sep-11 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.61 $ $Date: 1995/09/08 10:47:00 $
d16 5
a20 3
 *	__iexpr
 *		g_proc_DISPLAY
 *		g_proc_GOTO
d22 25
d155 2
a156 1
char     *to_c_filename	PROTOARGS((char *, char *));
d161 2
a162 1
char     *blkname;			/* Name of the routine/main	*/
d760 1
a760 1
  fprintf(f, "  long      __loffset, __ltemp;\n");
a766 4
  fprintf(f, "  DBLArg_t  ");
  for (i = 0;  i < MAX_NTEMP;  ++i)
    fprintf(f, "%s__s_%d", i ? ", " : "", i);
  fprintf(f, ";\n");
d770 1
a770 1
  fprintf(f, "  char     *__errortrap = NULL;\n");
d778 3
d833 1
d879 1
d890 6
d1023 2
d1063 4
d1981 1
d1993 1
d1995 1
a1995 1
  fprintf(f, "%*sdrt_delete(__io_channel, %s);\n", INDENT, key);
d2569 2
d2597 1
a2597 1
  g_proc_ioerror(ioex, lab, "READ", "EOF,ERR,LOCK,LONG");
d2673 1
d2845 1
a2845 1
      fprintf(f, "%*sdrt_write(__io_channel, &__an_arg);\n", INDENT);
d2866 1
a2866 1
      fprintf(f, "%*sdrt_writes(__io_channel, &__an_arg);\n", INDENT);
d2884 5
a2888 1
    fprintf(f, "%*s%s(", INDENT, find_string(s, T_ID));
d2892 4
d3100 14
@


1.61
log
@1995-Sep-08 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.60 $ $Date: 1995/09/06 10:45:58 $
@


1.60
log
@1995-Sep-06 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.59 $ $Date: 1995/09/05 11:44:00 $
d52 1
a52 1
	  g_data_init	PROTOARGS((Node_id)),
d239 2
d251 3
d263 17
a279 2
              fprintf(f, "%*s}       %s;\n", --indent * 2, "", bufnm);
              --indent;
d282 5
d291 2
a292 1
	      c_error("internal error: g_data_buffers callid=%d", callid);
d400 3
a402 3
  if ((lastspec == NIL) && initspec)	/* Set up initializer		*/
    {
      g_data_init(initspec);		/* Generate initialized data	*/
d423 1
a423 1
g_data_init(initspec)					/* Function	*/
d425 1
d430 4
a433 1
  fprintf(f, "\n= {\n");
d476 2
a477 1
  fprintf(f, "  }");
d493 1
a493 1
              "FATAL - internal limit - g_data_init_ele", node, len);
d1529 1
a1529 1
		            "unknown internal structure",
d1551 2
a1552 2
	          c_error("unknown internal structure for %s d=[%d]",
		          flags, d);
d1679 1
a1679 1
      fprintf(f, "%*sdrt_accept(__io_channel, &__an_arg);\n", INDENT);
d1886 7
a1892 5
  Node_id   d;

  d    = rnn(spec, T__FIRST, NIL);
  genref(d);
  fprintf(f, "%*sdrt_clear(&__an_arg);\n", INDENT);
d1976 1
a1976 1
    c_error("internal error - g_proc_DISPLAY no channel spec");
d2447 1
a2447 1
        c_error("OPEN mode - internal error: xt=%s(%d) d=[%d]", 
d2693 1
a2693 1
    c_error("internal error, no <ref> for STORE");
d2801 1
a2801 1
    c_error("internal error, no <ref> for WRITE");
d2822 1
a2822 1
    c_error("internal error, no <ref> for WRITES");
d2947 2
a2948 2
          c_error("internal error, bad condition %.*s (\"%s\")",
	          ln, xs, allow);
d2962 1
a2962 1
        c_error("internal error, label: no ERR entry");
d2990 1
a2990 1
	  c_error("internal error, no entry for %s", xs);
@


1.59
log
@1995-Sep-05 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.58 $ $Date: 1995/09/04 12:12:43 $
d50 1
a50 1
	  g_data_buffers PROTOARGS((Node_id, int)),
d60 1
a60 1
	  g_proc_code	PROTOARGS((Node_id, int)),
d63 2
a64 2
	  g_proc_decl_params PROTOARGS((Node_id, int)),
	  g_proc_decl_toarg_fixup PROTOARGS((Node_id, int)),
d233 1
a233 1
g_data_buffers(spec, dostruct)				/* Function	*/
d236 1
a240 1

d248 24
d835 1
a835 1
g_proc_code(spec, unused)				/* Function	*/
d837 2
a838 1
  int       unused;
d1018 1
a1018 1
g_proc_decl_params(spec, unused)			/* Function	*/
d1020 2
a1021 1
  int       unused;			/* Currently unused		*/
d1042 1
a1042 1
g_proc_decl_toarg_fixup(spec, unused)			/* Function	*/
d1044 2
a1045 1
  int       unused;			/* Currently unused		*/
d1577 1
a1577 1
      g_proc_code(spec, 0);		/* Generate code for statement	*/
d1677 1
a1677 1
  g_proc_code(spec, 0);			/* Generate code for block	*/
d2512 1
a2512 1
IsWait:
d2992 1
a2992 1
  fprintf(f, "%*s      _errortrap = (char *)0;\n", INDENT);
d2998 1
a2998 1
	fprintf(f, "%*s      _errortrap = \"%s\";\n", INDENT, iolab[i]);
@


1.58
log
@1995-Sep-04 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.57 $ $Date: 1995/08/02 12:38:58 $
d43 2
d170 1
d172 1
d199 1
a199 2
    c_error("%s increase MAX_TMP_ARGS, currently %d\n",
            _parse.file, MAX_TMP_ARGS);
d203 2
a204 2
    c_error("%s - genref([%d]) for %d arguments narg=%d my_narg_start=%d?\n",
            _parse.file, spec, narg - my_narg_start, narg, my_narg_start);
d220 1
d224 2
a226 1
  fclose(fh);
d600 1
d614 4
d628 1
d631 2
a633 1
/**/setbuf(fh, NULL);
d767 1
a767 2
            c_error("%s - function return types not implemented, yet",
	            _parse.file);
d800 2
a801 1
      fprintf(f, "  if (strcmp(\"%s\",  __errortrap) == 0) goto %s;\n",xs,xs);
d821 1
a821 1
      c_error("g_proc_code: spec=[%d], unexpected.  Internal error.\n");
d1147 1
a1147 2
	    c_error("%s - invalid $SCR_ATT option must be %s\n",
	            _parse.file,
d1197 1
a1197 2
	    c_error("%s - invalid $SCR_CLR option must be %s\n",
	            _parse.file,
d1237 1
a1237 2
	    c_error("%s - $SCR_POS only has two parameters: row, col\n",
	            _parse.file);
d1240 1
a1240 1
        c_error("%s - $SCR_POS missing column specification\n", _parse.file);
d1249 1
a1249 1
        c_error("%s - %s (max size is %d)\n", _parse.file,
d1267 1
a1267 1
/**/c_error("cannot call function %s in actual parameter list yet\n", xs);
d1307 2
a1308 2
        c_error("%s overflowing allocated args, %s",
	        _parse.file, "increase MAX_CALL_ARGS or MAX_TMP_ARGS");
d1345 1
a1345 1
		  if (ch == '"')
d1470 2
a1471 2
		    c_error("%s%s d=[%d] nd=[%d] nl=[%d] xt=%d:%s\n",
		            _parse.file, " - unknown internal structure ",
d1493 2
a1494 2
	          c_error("%s - unknown internal structure for %s d=[%d]\n",
		          _parse.file, flags, d);
d1508 1
a1508 1
	        c_error("%s - %s (max size is %d)\n", _parse.file,
a1511 1
              fprintf(f, "%*s__an_arg = ", INDENT);
d1513 3
a1515 3
	        "dbl_mkarg(\"%s\", (void *)%s, %s, \"%s\", ARG_ISVAR);\n",
                      blkname, addr, size, type
		     );
d1521 3
a1523 2
          "%*s__arg[%d] = dbl_mkarg(\"%s\", (void *)%s, %s, \"%s\", %s);\n",
           INDENT, *nargs,          caller,       addr, size, type, flags);
d1526 2
a1527 2
        c_error("%s - more than %d call arguments (!??!), GET REAL!\n",
	        _parse.file, MAX_CALL_ARGS);
d1576 1
a1576 2
        c_error("%s - assignment to type %c unimplemented\n",
	        _parse.file, result_type);
a1584 1
        fprintf(f, "%*s__an_arg = ", INDENT);
d1586 3
a1588 3
	        "dbl_mkarg(\"%s\", (void *)%s, %s, \"D%s\", ARG_ISVAR);\n",
                blkname, right, size, size
	       );
d1617 1
a1617 1
    c_warning("%s - not handling advanced ACCEPT options yet", _parse.file);
d1643 1
a1643 2
    c_error("%s - MAX_BLOCK_DEPTH of %d exceeded",
	    _parse.file, MAX_BLOCK_DEPTH);
d1669 1
a1669 1
  fprintf(f, "%*sgoto %s;\n", INDENT, find_string(d, T_ID));
d1704 1
a1704 2
	    c_error("%s - CASE <ref> of type \"%s\" - not implemented",
	            _parse.file, xs);
a1712 1
	    fprintf(f, "%*s__an_arg = ", INDENT);
d1714 3
a1716 2
	      "dbl_mkarg(\"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
                blkname, strlen(ref) - 1, ref, size, type);
d1751 1
a1751 2
	    c_error("%s - case range element %s %s not handled", 
		    _parse.file, to_token(xt), xs);
d1756 1
a1756 1
	      c_error("%s - substring not implemented", _parse.file);
d1760 2
a1761 2
	      c_error("%s - CASE %.*s (%s) %s (%c%d) - %s",
	              _parse.file, strlen(ref) - 1, ref, type,
d1772 1
a1772 2
	      c_error("%s - CASE %s, selector is string, not a number",
	              _parse.file, xs);
d1790 1
a1790 3
	      c_error("%s - CASE \"%s\", selector is numeric, not a string",
	              _parse.file, xs
		     );
d1792 1
a1792 2
	      c_error("%s - CASE \"%s\" %s",
	              _parse.file, xs,
d1795 1
a1795 2
	      c_warning("%s - CASE \"%s\" %s %d, padded on right",
	                _parse.file, xs,
d1864 1
a1864 1
        c_error("%s - cannot decrement non-number field %s", _parse.file, ref);
d1960 1
a1960 1
        c_error("g_proc_DO: internal error, spec=[%d] d=[%d] xt=%d:%s %s\n",
d2028 1
a2028 2
                c_error("%s - EXIT not in context of block %s",
		        _parse.file, lab);
d2033 1
a2033 1
      c_error("%s - There is no block named %s for EXIT", _parse.file, lab);
d2038 1
a2038 1
        c_error("%s - EXIT not in context of a BEGIN-END block", _parse.file);
d2051 1
a2051 1
    c_error("%s - EXITLOOP not inside a loop context", _parse.file);
d2061 1
a2061 1
/**/c_warning("%s - g_proc_FIND(spec=%d)", _parse.file, spec);
d2160 1
a2160 1
/**/c_warning("%s - g_proc_FRETURN(spec=%d)", _parse.file, spec);
d2195 2
a2196 2
	  c_error("%s - no label \"%s\" in program", _parse.file, xs);
	fprintf(f, "%*sgoto %s;\n", INDENT, xs);
d2209 3
a2211 3
	      c_error("%s - no label \"%s\" in program", _parse.file, xs);
	    fprintf(f, "%*s    case %d: goto %s;\n",
	            INDENT, ++__goto, xs);
d2218 1
a2218 1
        c_error("g_proc_GOTO: internal error, spec=[%d] d=[%d] xt=%d:%s %s\n",
d2272 1
a2272 1
        c_error("%s - cannot increment non-number field %s", _parse.file, ref);
d2290 3
a2292 2
  fprintf(f, "%s:%.*s/* LABEL\t*/\n", label,
	  (64 - strlen(label) - 2) / 8, "\t\t\t\t\t\t\t");
d2311 1
a2311 1
        c_warning("%s - why LOCASE numeric field %s?", _parse.file, ref);
d2322 1
a2322 1
/**/c_warning("%s - g_proc_LPQUE(spec=%d)", _parse.file, spec);
d2332 1
a2332 1
    c_error("%s - NEXTLOOP not inside a loop context", _parse.file);
d2359 1
a2359 1
    c_error("%s - undefined label \"%s\" used in ONERROR\n", _parse.file, lab);
d2387 2
a2388 2
        c_error("%s - OPEN mode - internal error: xt=%s(%d) d=[%d]\n", 
	        _parse.file, to_token(xt), xt, d);
a2405 1
	fprintf(f, "%*s__an_arg = ", INDENT);
d2407 3
a2409 2
          "dbl_mkarg(\"%s\", (void *)\"%s\", %d, \"A%d\", ARG_ISCONST);\n",
                blkname, buf, strlen(buf), strlen(buf));
d2423 1
a2423 2
        c_warning("%s - not handling OPEN %s spec yet - ignored",
                  _parse.file, to_token(xt));
d2456 1
a2456 1
/**/c_warning("%s - g_proc_READ(spec=%d)", _parse.file, spec);
d2500 1
a2500 1
/**/c_warning("%s - g_proc_READS(spec=%d)", _parse.file, spec);
d2512 1
a2512 1
/**/c_warning("%s - g_proc_RECV(spec=%d)", _parse.file, spec);
d2566 1
a2566 1
/**/c_warning("%s - g_proc_SEND(spec=%d)", _parse.file, spec);
d2575 1
a2575 1
/**/c_warning("%s - g_proc_SORT(spec=%d)", _parse.file, spec);
d2633 1
a2633 1
    c_error("%s - internal error, no <ref> for STORE", _parse.file);
d2664 1
a2664 1
        c_warning("%s - why UPCASE numeric field %s?", _parse.file, ref);
d2675 1
a2675 1
/**/c_warning("%s - g_proc_USING(spec=%d)", _parse.file, spec);
d2716 1
a2716 1
      c_error("g_proc_WHILE: internal error, spec=[%d] d=[%d] no T__EXPR\n",
d2736 1
a2736 1
        c_warning("%s - not handling advanced WRITE options yet", _parse.file);
d2741 1
a2741 1
    c_error("%s - internal error, no <ref> for WRITE", _parse.file);
d2757 1
a2757 1
        c_warning("%s - not handling advanced WRITES options yet", _parse.file);
d2762 1
a2762 1
    c_error("%s - internal error, no <ref> for WRITES", _parse.file);
d2887 2
a2888 2
          c_error("%s - internal error, bad condition %.*s (\"%s\")\n",
	          _parse.file, ln, xs, allow);
d2902 1
a2902 1
        c_error("%s - internal error, label: no ERR entry", _parse.file);
d2906 1
a2906 1
        c_error("%s - %s=%s unknown label", _parse.file, ioex[i].name, xs);
d2930 1
a2930 1
	  c_error("%s - internal error, no entry for %s", _parse.file, xs);
d2936 1
a2936 1
        c_error("%s - can't have %s exception on %s", _parse.file, xs, command);
d2942 2
a2943 2
            c_warning("%s - already have %s=%s, label %s ignored",
	              _parse.file, ioex[i].name, iolab[i], xs);
d2947 1
a2947 2
                c_error("%s - %s=%s unknown label", _parse.file,
		        ioex[i].name, xs);
@


1.57
log
@1995-Aug-02 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.56 $ $Date: 1995/08/01 11:52:05 $
d2430 1
a2430 2
  fprintf(f, "%*s__io_status = drt_open(__io_channel, %s, %s);\n", INDENT,
          "&__arg[0]", "&__arg[1]");
d2455 2
d2463 31
d2616 1
a2617 3
  char      key[BUFSIZ];

  strcpy(key, "(DBLArg_t *)NULL");
d2625 2
a2626 2
      fprintf(f, "%*s__arg[0] = __an_arg; /* save key */\n", INDENT);
      strcpy(key, "&__arg[0]");
d2631 2
a2632 1
      fprintf(f, "%*sdrt_store(__io_channel, &__an_arg, %s);\n", INDENT, key);
d2817 1
a2817 2
  fprintf(f, "%*s__io_status = drt_%s(__io_channel, %s, %s);\n",
          INDENT, rtn, "&__arg[0]", "&__arg[1]");
d2840 2
a2841 1
  fprintf(f, "%*s__io_status = drt_%s(__io_channel, &an_arg);\n", INDENT, rtn);
d2916 5
d2924 2
a2925 1
      e = rnn(d, T__LEFT, NIL);		/* Get condition		*/
@


1.56
log
@1995-Aug-01 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.55 $ $Date: 1995/07/21 12:24:48 $
d736 2
a737 1

d818 7
a824 2
        fprintf(f, "  __lineno = \"%s\";%*s\t/*   [%5d]\t*/\n",
	        _parse.file = xs, (39 - strlen(xs)), "", d);
d838 1
a838 1
/**/	  case T_O_EQUAL:	g_proc_assign(d);		break;
d856 1
a856 1
/**/	  case T_FORMS:		g_proc_FORMS(d);		break;
d956 1
a956 1
  fprintf(f, "char     *__lineno;\t\t\t/* Current source line\t\t*/\n");
a970 1
      fprintf(f, "  __lineno = \"drt_INIT call\";\n");
a971 1
      fprintf(f, "  __lineno = \"calling %s\";\n", blkname);
a972 1
      fprintf(f, "  __lineno = \"returned from %s\";\n", blkname);
d1035 6
a1557 4
/**/c_warning("%s - g_proc_assign(spec=%d)", _parse.file, spec);
  fprintf(f, "%*s/* g_proc_assign(spec=%d) result_type='%c' */\n",
          INDENT, spec, result_type);

a2148 2
/**/c_warning("%s - g_proc_FORMS(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_FORMS(spec=%d) */\n", spec);
d2152 3
d2927 6
a2932 6
  fprintf(f, "%*s{\n", INDENT);
  fprintf(f, "%*s  case DBL_IOS_OK:\n", INDENT);
  fprintf(f, "%*s    break;\n", INDENT);
  fprintf(f, "%*s  default:\n", INDENT);
  fprintf(f, "%*s    _errortrap = (char *)0;\n", INDENT);
  fprintf(f, "%*s    goto _error_trap;\n", INDENT);
d2936 3
a2938 3
	fprintf(f, "%*s  case %s:\n", INDENT, ioex[i].exception);
	fprintf(f, "%*s    _errortrap = \"%s\";\n", INDENT, iolab[i]);
	fprintf(f, "%*s    goto _error_trap;\n", INDENT);
d2940 1
a2940 1
  fprintf(f, "%*s}\n", INDENT);
@


1.55
log
@1995-Jul-21 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.54 $ $Date: 1995/07/18 12:39:25 $
@


1.54
log
@1995-Jul-18 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.53 $ $Date: 1995/07/17 12:40:49 $
d1300 1
d1352 8
@


1.53
log
@1995-Jul-17 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.52 $ $Date: 1995/07/12 14:07:17 $
d121 4
a124 1
          g_proc_iochannel PROTOARGS((Node_id));
d852 2
a853 2
/**/	  case T_GET:		g_proc_GET(d);			break;
/**/	  case T_GETS:		g_proc_GETS(d);			break;
d865 2
a866 2
/**/	  case T_PUT:		g_proc_PUT(d);			break;
/**/	  case T_PUTS:		g_proc_PUTS(d);			break;
d2156 1
a2156 6
  Node_id   d, s;
/**/c_warning("%s - g_proc_GET(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_GET(spec=%d) */\n", spec);
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
d2164 1
a2164 7
  int       xt;
  Node_id   d, s;
/**/c_warning("%s - g_proc_GETS(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_GETS(spec=%d) */\n", spec);
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
d2356 1
a2357 1
  char     *ioex;
d2366 1
a2366 27
  ioex = NULL;				/* No exception label		*/
  if (d = rnn(s, T__FIRST, NIL))	/* Get exception label (if any)	*/
    {
      do
        {
	  e = rnn(d, T__LEFT, NIL);	/* Get condition		*/
	  ng(e, &xt, &xs);		/* Get name of condition	*/
	  if (strcmp("ERR", xs) != 0)
	    c_error("%s - can't have %s exception on OPEN", _parse.file, xs);
	  else
	    {
	      e = rnn(d, T__RIGHT, NIL);/* Get label for exception	*/
	      ng(e, &xt, &xs);		/* Get name of label		*/
	      if (ioex)
	        c_warning("%s - already have ERR=%s, label %s ignored",
		          _parse.file, ioex, xs);
	      else
	        {
		  if ( ! lkupid(e, T_LABEL) )
	            c_error("%s - ERR=%s unknown label", _parse.file, ioex);
	          else
	            ioex = xs;		/* Save label			*/
		}
	    }
	}
      while (d = rnn(d, T__PRECEDES, NIL));
    }
a2414 2
  fprintf(f, "%*s__errortrap = ", INDENT);
  fprintf(f, ioex ? "\"%s\";\n" : "(char *)0;\n", ioex);
d2417 1
a2417 1
  fprintf(f, "%*sif (__io_status) goto _error_trap;\n", INDENT);
d2425 1
a2425 6
  Node_id   d, s;
/**/c_warning("%s - g_proc_PUT(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_PUT(spec=%d) */\n", spec);
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
d2433 1
a2433 6
  Node_id   d, s;
/**/c_warning("%s - g_proc_PUTS(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_PUTS(spec=%d) */\n", spec);
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __io_channel*/
d2747 180
@


1.52
log
@1995-Jul-12 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.51 $ $Date: 1995/07/05 12:50:47 $
d658 1
d839 1
a839 1
/**/	  case T_DISPLAY:	g_proc_DISPLAY(d);		break;
d861 1
a861 1
/**/	  case T_OPEN:		g_proc_OPEN(d);			break;
a1895 1
/**/c_warning("%s - g_proc_DISPLAY(spec=%d)", _parse.file, spec);
d2362 7
a2368 3
  Node_id   d, s;
/**/c_warning("%s - g_proc_OPEN(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_OPEN(spec=%d) */\n", spec);
d2370 1
d2373 81
@


1.51
log
@1995-Jul-05 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.50 $ $Date: 1995/07/03 12:17:39 $
d1305 3
a1307 3
	    flags = "ARG_ISCONST";
	    sprintf(size, "%d", MAX_NUM_DIGITS);
	    type  = "D18";
d1309 1
a1309 1
	            MAX_NUM_DIGITS - strlen(argstring), "000000000000000000",
d1537 2
a1538 1
  fprintf(f, "%*s/* g_proc_assign(spec=%d) */\n", INDENT, spec);
@


1.50
log
@1995-Jul-03 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.49 $ $Date: 1995/06/30 11:14:44 $
d661 2
a662 1
  fprintf(f, "  long long __nexpr, __ntemp, __nby, __nthru;\n");
d1150 3
a1152 3
      strcpy(size, "18");
      *type  = "D18 $SCR_ATT";
      sprintf(addr, "\"%0*d\"", 18, dattr);
d1195 3
a1197 3
      strcpy(size, "18");
      *type  = "D18 $SCR_CLR";
      sprintf(addr, "\"%0*d\"", 18, dattr);
d1219 2
a1220 2
      fprintf(f, "%*ssprintf(&__xargbuf[%d], \"%%018d\", %s);\n",
              INDENT, *xargbufp, "(DBL_DA_POS | (__row << 8) | __col)"
d1306 1
a1306 1
	    strcpy(size, "18");
d1309 1
a1309 1
	            18 - strlen(argstring), "000000000000000000",
d1486 1
a1486 1
	      fprintf(f, "%*sdbl_putn(&__an_arg, __nexpr);\n", INDENT);
a1530 1
  int       dtoa = 0;
a1544 1
  /* set dtoa depending on left<A> = right<D> */
a1553 1
	fprintf(f, "%*s%s[%s] = '\\0';\n", INDENT, right, size);
d1563 1
a1563 1
	fprintf(f, "%*sdbl_putn(&__an_arg, __nexpr);\n", INDENT);
d1575 3
a1577 3
           ? "%*sdbl_putsf(&__an_arg, %d, \"%s\", %s, __format);\n"
           :  "%*sdbl_puts(&__an_arg, %d, \"%s\", %s);\n",
	  INDENT, dtoa, align, right);
d2107 1
a2107 1
  fprintf(f, "%*sdbl_putn(&__an_arg, __nexpr);\n", INDENT);
d2116 1
a2116 1
  fprintf(f, "%*sdbl_putn(&__an_arg, __nexpr);\n", INDENT);
@


1.49
log
@1995-Jun-30 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.48 $ $Date: 1995/06/29 09:14:21 $
d88 2
d101 2
d847 2
d860 2
d1052 1
a1052 1
  if      (strcmp(xs, "$RDLEN")   == 0)
d1054 36
a1091 3
/*
INPUT(1,$RDLEN)
 */
d1097 5
a1101 3
/*
$RDTRM
 */
d1231 6
a1240 3
/*
$TRUNC(TOTAL*100)
 */
d1316 12
a1327 1
	    sprintf(addr, "\"%s\"", argstring);
d1530 1
d1545 1
d1555 1
d1566 1
d1577 3
a1579 3
           ? "%*sdbl_putsf(&__an_arg, \"%s\", %s, __format);\n"
           :  "%*sdbl_puts(&__an_arg, \"%s\", %s);\n",
	  INDENT, align, right);
d2151 27
d2370 26
@


1.48
log
@1995-Jun-29 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.47 $ $Date: 1995/06/28 09:53:03 $
d1535 2
a1536 5
      int       narg = 0;
      g_proc_mkargs(&narg, blkname, d);
      if (narg != 1)
        c_error("%s - internal error, ACCEPT with %d args", _parse.file, narg);
      fprintf(f, "%*sdrt_accept(__io_channel, &__arg[0]);\n", INDENT);
a1751 1
  char     *ref, *size, *type;
d1754 1
a1754 4
  c_ref(d, &ref, &size, &type);
  fprintf(f, "%*s__an_arg = ", INDENT);
  fprintf(f, "dbl_mkarg(\"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
          blkname, strlen(ref) - 1, ref, size, type);
d1787 1
a1787 1
        c_error("%s - cannot increment non-number field %s", _parse.file, ref);
d1811 2
a1812 5
      int       narg = 0;
      g_proc_mkargs(&narg, blkname, d);
      if (narg != 1)
        c_error("%s - internal error, DELETE with %d args", _parse.file, narg);
      strcpy(key, "&__arg[0]");
d1998 1
a1998 2
  int       narg = 0;
  Node_id   s = rnn(spec, T__FIRST, NIL);
d2000 2
a2001 5
  g_proc_mkargs(&narg, blkname, s);	/* Setup arguments		*/
  if (narg != 1)
    c_error("%s - internal error, FLUSH [%d] with %d args",
            _parse.file, spec, narg);
  fprintf(f, "%*sdrt_flush(&__arg[0]);\n", INDENT);
a2009 1
  int       xt, r;
a2010 2
  char     *xs;
  char     *cvar, *cvarsz, *cvarty;
d2047 1
a2047 4
  c_ref(rnn(d, T__REF, NIL), &cvar, &cvarsz, &cvarty);
  fprintf(f, "%*s__an_arg = ", INDENT);
  fprintf(f, "dbl_mkarg(\"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
              blkname, strlen(cvar) - 1, cvar, cvarsz, cvarty);
d2055 1
a2055 4
  c_ref(rnn(d, T__REF, NIL), &cvar, &cvarsz, &cvarty);
  fprintf(f, "%*s__an_arg = ", INDENT);
  fprintf(f, "dbl_mkarg(\"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
              blkname, strlen(cvar) - 1, cvar, cvarsz, cvarty);
d2218 1
a2218 1
        c_warning("%s - why locase numeric field %s?", _parse.file, ref);
d2220 1
a2220 3
  fprintf(f, "%*s__an_arg = ", INDENT);
  fprintf(f, "dbl_mkarg(\"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
              blkname, strlen(ref) - 1, ref, size, type);
d2404 1
a2404 29
      int       xt;
      char     *ref, *size, *type;
      char      szbuf[10];
      ng(d, &xt, &ref);
      switch (xt)
        {
	  case T_ID:
            c_ref(d, &ref, &size, &type);
	    fprintf(f, "%*__an_arg = ", INDENT);
            fprintf(f,
	      "dbl_mkarg(\"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
                    blkname, strlen(ref) - 1, ref, size, type);
	    break;
	  case T_NUMBER:
	    sprintf(szbuf, "D%d", strlen(ref));
	    /* fall-thru */
	  case T_STRING:
	    if (xt == T_STRING)
	      sprintf(szbuf, "A%d", strlen(ref));
	    type = &szbuf[0];
	    size = &szbuf[1];
	    fprintf(f, "%*__an_arg = ", INDENT);
            fprintf(f,
	      "dbl_mkarg(\"%s\", (void *)%s, %s, \"%s\", ARG_ISVAR);\n",
                    blkname, ref, size, type);
	    break;
	  default:
	    c_error("%s - internal error STOP xt=%d\n", _parse.file, xt);
	}
d2426 3
a2428 7
      int       narg = 0;
      g_proc_mkargs(&narg, blkname, d);
      if (narg != 1)
        c_error("%s - internal error, STORE with %d key args",
	        _parse.file, narg);
      fprintf(f, "%*s__arg[1] = __arg[0]; /* save key */\n", INDENT);
      strcpy(key, "&__arg[1]");
d2432 2
a2433 6
      int       narg = 0;
      g_proc_mkargs(&narg, blkname, d);
      if (narg != 1)
        c_error("%s - internal error, STORE with %d key refs",
	        _parse.file, narg);
      fprintf(f, "%*sdrt_store(__io_channel, &__arg[0], %s);\n", INDENT, key);
d2467 1
a2467 1
        c_warning("%s - why locase numeric field %s?", _parse.file, ref);
d2469 1
a2469 3
  fprintf(f, "%*s__an_arg = ", INDENT);
  fprintf(f, "dbl_mkarg(\"%s\", (void *)%.*s, %s, \"%s\", ARG_ISVAR);\n",
              blkname, strlen(ref) - 1, ref, size, type);
a2487 1
  int       xt, r;
a2488 1
  char     *xs;
a2537 1
      int       narg = 0;
d2540 2
a2541 5
      g_proc_mkargs(&narg, blkname, d);
      if (narg != 1)
        c_error("%s - internal error, WRITE with %d refs",
	        _parse.file, narg);
      fprintf(f, "%*sdrt_write(__io_channel, &__arg[0]);\n", INDENT);
a2558 1
      int       narg = 0;
d2561 2
a2562 5
      g_proc_mkargs(&narg, blkname, d);
      if (narg != 1)
        c_error("%s - internal error, WRITES with %d refs",
	        _parse.file, narg);
      fprintf(f, "%*sdrt_writes(__io_channel, &__arg[0]);\n", INDENT);
@


1.47
log
@1995-Jun-28 Checkpoint. Happy 17th birthday, Kara\!
@
text
@d3 1
a3 1
 * $Revision: 1.46 $ $Date: 1995/06/23 11:19:22 $
d41 1
d173 5
d183 8
a190 1
  int       narg;
d192 5
a196 2
  if (narg != 1)
    c_error("%s - genref([%d]) for %d arguments?\n", _parse.file, spec, narg);
d651 1
d653 1
a653 1
  fprintf(f, "  DBLArg_t  __an_arg, __arg[MAX_CALL_ARGS];\n");
d1205 8
d1222 6
a1227 1
  *nargs = 0;
d1236 4
d1435 2
a1436 1
      if (++*nargs > MAX_CALL_ARGS)
d1516 2
a1517 2
           ? "%*sdbl_putsf(&__arg[0], \"%s\", %s, __format);\n"
           :  "%*sdbl_puts(&__arg[0], \"%s\", %s);\n",
d1535 1
a1535 1
      int       narg;
d1800 1
a1800 1
  fprintf(f, "%*sdrt_decr(&__arg[0]);\n", INDENT);
d1818 1
a1818 1
      int       narg;
d1853 1
a1853 1
    int       i, narg;
d2008 1
a2008 1
  int       narg;
d2209 1
a2209 1
  fprintf(f, "%*sdrt_incr(&__arg[0]);\n", INDENT);
d2246 1
a2246 1
  fprintf(f, "%*sdrt_locase(&__anarg);\n", INDENT);
d2479 1
a2479 1
      int       narg;
d2489 1
a2489 1
      int       narg;
d2603 1
a2603 1
      int       narg;
d2628 1
a2628 1
      int       narg;
@


1.46
log
@1995-Jun-23 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.45 $ $Date: 1995/06/21 12:40:42 $
d121 5
a128 2
char     *blkname;			/* Name of the routine/main	*/
static
d170 18
d474 1
d636 1
a636 1
  fprintf(f, "  DBLArg_t  __arg[MAX_CALL_ARGS];\n");
d645 4
d1331 1
a1331 1
		  fprintf(f, "%*s__ipos = (int)__ntemp;\n", INDENT);
d1338 1
a1338 1
		      fprintf(f, "%*s__isize = (int)__ntemp;\n", INDENT);
d1343 1
a1343 1
		      fprintf(f,"%*s__isize = (int)__ntemp - __ipos + 1;\n",
d1389 6
a1394 3
	      fprintf(f, "%*sdbl_putn(%s, %s, \"%s\", __ntemp);\n",
		      INDENT, addr, size, type
	             );
d1465 6
d1478 1
a1478 1
  c_ref(rnn(spec, T__LEFT, NIL), &ref, &size, &type);
d1481 3
a1483 3
           ? "%*sdbl_putsf((void *)%.*s, %s, \"%s\", \"%s\", %s, __format);\n"
           :  "%*sdbl_puts((void *)%.*s, %s, \"%s\", \"%s\", %s);\n",
	  INDENT, strlen(ref) - 1, ref, size, type, align, right);
d1598 5
a1602 2
	    fprintf(f, "%*s__iexpr = dbl_num((void *)%.*s, %s, \"%s\");\n",
	            INDENT, strlen(ref) - 1, ref, size, type);
d1724 4
a1727 2
  fprintf(f, "%*sdrt_clear(%.*s, %s, \"%s\");\n",
          INDENT, strlen(ref) - 1, ref, size, type);
d1764 2
a1765 2
  fprintf(f, "%*sdrt_decr(%.*s, %s, \"%s\");\n",
          INDENT, strlen(ref) - 1, ref, size, type);
d2030 4
a2033 2
  fprintf(f, "%*sdbl_putn(%.*s, %s, \"%s\", __nexpr);\n", INDENT,
          strlen(cvar) - 1, cvar, cvarsz, cvarty);
d2041 5
a2045 4
  fprintf(f, "%*s__nexpr = dbl_num((void *)%.*s, %s, \"%s\") + __nby;\n",
          INDENT, strlen(cvar) - 1, cvar, cvarsz, cvarty);
  fprintf(f, "%*sdbl_putn(%.*s, %s, \"%s\", __nexpr);\n", INDENT,
          strlen(cvar) - 1, cvar, cvarsz, cvarty);
d2047 1
a2047 1
  fprintf(f, "%*s__iexpr = __nexpr > __nthru;\n", INDENT);
d2173 2
a2174 2
  fprintf(f, "%*sdrt_incr(%.*s, %s, \"%s\");\n",
          INDENT, strlen(ref) - 1, ref, size, type);
d2208 4
a2211 2
  fprintf(f, "%*sdrt_locase(%.*s, %s, \"%s\");\n",
          INDENT, strlen(ref) - 1, ref, size, type);
d2402 4
a2405 2
            fprintf(f, "%*sdrt_stop(%.*s, %s, \"%s\");\n",
                    INDENT, strlen(ref) - 1, ref, size, type);
d2415 4
a2418 2
	    fprintf(f, "%*sdrt_stop(\"%s\", %s, \"%s\");\n",
                    INDENT, ref, size, type);
d2423 1
d2495 4
a2498 2
  fprintf(f, "%*sdrt_upcase(%.*s, %s, \"%s\");\n",
          INDENT, strlen(ref) - 1, ref, size, type);
@


1.45
log
@1995-Jun-21 Checkpoint. hello.dbl runs\!
@
text
@d3 1
a3 1
 * $Revision: 1.44 $ $Date: 1995/06/20 12:17:31 $
d105 1
d818 1
d1051 2
d2316 9
@


1.44
log
@1995-Jun-20 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.43 $ $Date: 1995/06/15 09:12:44 $
d59 1
d603 1
a603 1
  fprintf(f, "    drt__FATAL(\"CALL stack overflow\");\n");
d764 2
a765 1
        fprintf(f, "\t\t\t\t\t/* %-20s [%5d] */\n", _parse.file = xs, d);
d855 1
d861 1
d879 41
d1181 4
a1184 2
/**/printf("g_proc_mkargs: d=[%d] xt=%s(%d), xs=\"%s\"\n",
/**/       d, to_token(argtype), argtype, argstring);
d1258 1
d1261 1
d1282 1
d1285 1
@


1.43
log
@1995-Jun-15 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.42 $ $Date: 1995/06/14 08:57:35 $
d32 1
d612 1
a612 1
  fprintf(f, "  DBLArg    __arg[MAX_CALL_ARGS];\n");
d614 1
a614 1
  fprintf(f, "  int       __io_channel;\n");
d942 169
a1110 1
  fprintf(f, "%*s/*parameter subr call spec=[%d]\n", INDENT, spec);
d1163 10
a1172 1
	      if (rnn(d, T__SUBR, NIL))	/* This is a subroutine call	*/
d1314 3
a1316 3
/**/fprintf(f, "/* type=\"%s\" */\n", type);
      fprintf(f, "%*s__arg[%d] = dbl_mkarg(\"%s\", (void *)%s, %s, '%.1s', %s);\n",
              INDENT, *nargs, caller, addr, size, type, flags);
d1681 1
a1681 1
  strcpy(key, "(DBLArg *)NULL");
d1729 1
a1729 1
    fprintf(f, "%*s%*s (DBLArg *)NULL\n", INDENT, strlen(rtn), "");
d2323 1
a2323 1
  strcpy(key, "(DBLArg *)NULL");
@


1.42
log
@1995-Jun-14 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.41 $ $Date: 1995/06/12 11:37:02 $
d1060 1
d1062 2
d1071 1
a1071 1
		  c_nexpr(f, indent, rnn(nd, T__EXPR, NIL));
d1073 4
a1076 1
		  if      (nl = rnn(nd, T_O_COMMA, NIL))
d1081 1
a1081 1
		  else if (nl = rnn(nd, T_O_COLON, NIL))
d1088 4
a1091 3
		    c_error("%s - unknown internal structure d=[%d] nd=[%d]\n",
		            _parse.file, d, nd);
	          fprintf(f, "%*s__loffset += __ipos;\n", INDENT);
@


1.41
log
@1995-Jun-12 Checkpoint 2
@
text
@d3 1
a3 1
 * $Revision: 1.40 $ $Date: 1995/06/12 09:15:28 $
d61 2
d511 5
a515 1
    ep = strchr(bp = strchr(strchr(version, ' ') + 1, ' ') + 1, ' ');
d932 12
d993 8
d1168 1
a1168 1
  char      result_type, *right;
d1198 4
d1204 5
a1208 4
  fprintf(f, fmt
               ? "%*sdbl_putsf((void *)%.*s, %s, \"%s\", %s, __format);\n"
               : "%*sdbl_puts((void *)%.*s, %s, \"%s\", %s);\n",
	  INDENT, strlen(ref) - 1, ref, size, type, right);
d1537 10
a1546 7
  for (r = T__FIRST;  d = rnn(d, r, NIL);  r = T__PRECEDES)
    {
/**/if (_parse.flags) printf("DISPLAY d=[%d]\n", d);
      fprintf(f, "%*sdrt_display(__io_channel, 1/*spec=[%d]*/);\n",
             INDENT, /**/ d
	    );
    }
@


1.40
log
@1995-Jun-12 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.39 $ $Date: 1995/06/09 11:19:42 $
d771 1
a771 1
/**/	  case T_ACCEPT:	g_proc_ACCEPT(d);		break;
d778 1
a778 1
/**/	  case T_DELETE:	g_proc_DELETE(d);		break;
d786 1
a786 1
/**/	  case T_FLUSH:		g_proc_FLUSH(d);		break;
d809 1
a809 1
/**/	  case T_STORE:		g_proc_STORE(d);		break;
d1103 1
d1185 15
a1199 2
/**/c_warning("%s - g_proc_ACCEPT(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_ACCEPT(spec=%d) */\n", spec);
d1430 2
a1431 2
      g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
      fprintf(f, "%*sdrt_close(__iexpr);\n", INDENT);
d1463 4
a1466 2
/**/c_warning("%s - g_proc_DELETE(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_DELETE(spec=%d) */\n", spec);
d1469 10
a1478 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d1502 1
a1502 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d1651 1
a1651 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d1659 8
a1666 2
/**/c_warning("%s - g_proc_FLUSH(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_FLUSH(spec=%d) */\n", spec);
d1747 1
a1747 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d1951 1
a1951 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d1964 1
a1964 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d1977 1
a1977 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d2101 29
a2129 2
/**/c_warning("%s - g_proc_STORE(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_STORE(spec=%d) */\n", spec);
d2227 1
a2227 2
/**/c_warning("%s - g_proc_WRITE(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_WRITE(spec=%d) */\n", spec);
d2230 14
a2243 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d2252 1
a2252 2
/**/c_warning("%s - g_proc_WRITES(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_WRITES(spec=%d) */\n", spec);
d2255 14
a2268 1
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d2277 1
a2277 1
  int       nargs = 0;
d2280 1
a2280 1
    g_proc_mkargs(&nargs, blkname, d);	/* Setup arguments		*/
d2284 1
a2284 1
    for (i = 0;  i < nargs;  ++i)	/* Build parameter list		*/
@


1.39
log
@1995-Jun-09 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.38 $ $Date: 1995/06/06 11:47:20 $
d566 2
d606 1
a606 1
  fprintf(f, "  int       __iexpr, __isize;\n");
a607 1
  fprintf(f, "  long long __nexpr, __ntemp, __nby, __nthru");
d609 2
d612 1
a612 1
    fprintf(f, ", __n_%d", i);
d614 2
a615 1
  fprintf(f, "  char      __string[BUFSIZ], __number[BUFSIZ], __format[BUFSIZ];\n");
d816 1
a816 1
/**/	  case T_XCALL:		g_proc_XCALL(d);		break;
d912 2
a913 2
      fprintf(f, "%*sdbl_toarg(\"%s\", \"%s\", &%s, %s, '%.1s');\n", INDENT,
              blkname, name, name, find_string(t, T__SIZE_BUFFER), type
d934 1
d970 1
a970 1
	    strcpy(size, argstring);
d977 1
a977 1
	      Node_id   t, tt, nd, nt;
d993 1
d1000 12
a1011 3
/**/printf("mkargs: c_nexpr nd=[%d]\n", nd);
/**/fprintf(f, "mkargs: c_nexpr nd=[%d]\n", nd);
		      c_nexpr(f, indent, nd);
d1030 2
a1031 1
/**/fprintf(f, "mkargs: substr d=[%d] tt=[%d]\n", d, tt);
d1034 3
d1042 17
a1058 5
	          strcpy(size, "TBD");
/*
      c_nexpr(f, indent, e);
      fprintf(f, "%*s__iexpr = (int)__nexpr;\n", INDENT);
 */
d1060 8
a1067 2
	      sprintf(addr, "(char *)&%s%s",
	                     argstring, hasoffset ? " + _loffset" : "");
d1072 29
d1103 1
a1103 1
      fprintf(f, "%*s__arg[%d] = dbl_mkarg(\"%s\", %s, %s, '%.1s', %s);\n",
d1174 2
a1175 2
               ? "%*sdbl_putsf(%.*s, %s, \"%s\", %s, __format);\n"
               : "%*sdbl_puts(%.*s, %s, \"%s\", %s);\n",
d1278 2
a1279 2
	    fprintf(f, "%*s__iexpr = dbl_num(%.*s, %s, \"%s\");\n", INDENT,
	            strlen(ref) - 1, ref, size, type);
d1694 2
a1695 2
  fprintf(f, "%*s__nexpr = dbl_num(%.*s, %s, \"%s\") + __nby;\n", INDENT,
          strlen(cvar) - 1, cvar, cvarsz, cvarty);
a2195 2
/**/c_warning("%s - g_proc_XCALL(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_XCALL(spec=%d) */\n", spec);
d2199 1
a2199 1
  { /* block */
@


1.38
log
@1995-Jun-06 Checkpoint
@
text
@d3 1
a3 1
 * $Revision: 1.37 $ $Date: 1995/05/15 10:22:11 $
d39 1
a39 1
#define MAX_CALL_ARGS	20
d61 1
d604 1
a604 1
  fprintf(f, "  int       __iexpr;\n");	/* Small 'int' expr results	*/
d606 2
a607 1
  fprintf(f, "  long long __nexpr, __nby, __nthru");
d924 124
d2128 2
d2132 10
@


1.37
log
@1995-May-15 Checkpoint
@
text
@d2 2
a3 2
 * $Locker: ldl $ $Source: /home/ldl/dbl/cdbl/RCS/generate.c,v $
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.36 1995/05/02 10:43:19 ldl Exp ldl $
d39 1
d59 2
d122 2
a512 1
  fprintf(f, " * $Locker%c $Header%c\n", '$', '$');
d514 1
d599 4
d618 3
d849 1
d875 6
a880 3
    fprintf(f, "%s\n%*s%s", (r == T__FIRST) ? "" : ",", indent, "",
		find_string(d, T_LABEL)
	   );
d885 37
d956 1
a956 1
  fprintf(f, "%*s/* g_proc_assign(spec=%d)\n", INDENT, spec);
@


1.36
log
@1995-May-02 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.35 1995/04/25 11:48:28 ldl Exp ldl $
d664 1
d667 1
d1094 1
a1094 1
	        fprintf(f, "%*s%sif%s (iexpr >= %5d || iexpr <= %5d)\n",
d1101 1
a1101 1
	      fprintf(f, "%*s%sif%s (iexpr == %5d)\n", INDENT,
d1238 1
a1238 1
/**/printf("DISPLAY d=[%d]\n", d);
d1440 1
a1440 1
  fprintf(f, "%*sdrt_putn(%.*s, %s, \"%s\", __nexpr);\n", INDENT,
d1451 1
a1451 1
  fprintf(f, "%*sdrt_putn(%.*s, %s, \"%s\", __nexpr);\n", INDENT,
d1798 1
a1798 1
            fprintf(f, "%*sdbl_stop(%.*s, %s, \"%s\");\n",
d1809 1
a1809 1
	    fprintf(f, "%*sdbl_stop(\"%s\", %s, \"%s\");\n",
d1817 1
a1817 1
    fprintf(f, "%*sdbl_terminate();\n", INDENT);
d1967 1
a1967 1
  fprintf(f, "%*s__io_channel = (int)_nexpr;\n", INDENT);
@


1.35
log
@1995-Apr-25 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.34 1995/04/24 12:23:14 ldl Exp ldl $
d600 1
a600 1
  fprintf(f, "  char      __string[BUFSIZ], __number[BUFSIZ];\n");
d735 2
a736 2
      if ( _parse.file = find_string(d, T__FILE_LINENO) )
        fprintf(f, "\t\t\t\t\t/* %-20s [%5d] */\n", _parse.file, d);
d754 1
a754 1
/**/	  case T_CASE:		g_proc_CASE(d);			break;
d787 1
a787 1
/**/	  case T_SLEEP:		g_proc_SLEEP(d);		break;
d894 2
a895 2
  char     *left, *right, *format;
  left = right = format = "";
d897 3
a901 6
  fprintf(f, "%*s/* right <expr> */\n", INDENT);
  fprintf(f, "%*s/* format <expr> */\n", INDENT);
/*
  right  = c_expr(rnn(spec, T__RIGHT,  NIL));
  format = c_expr(rnn(spec, T_O_COMMA, NIL));
 */
d903 7
a909 7
/*
  free(right);
  free(format);
 */

  c_ref(rnn(spec, T__LEFT, NIL), &ref, &size, &type);
  switch (type[0])
d912 3
a914 1
        c_error("%s - internal error g_proc_assign type=%s", _parse.file,type);
d916 1
d918 1
a918 1
        break;
d920 1
d922 1
a922 1
        break;
d924 6
a929 2
  fprintf(f, "%*sdbl_puts(%.*s, %s, \"%s\", %s);\n",
	        INDENT, strlen(ref) - 1, ref, size, type, right);
d995 147
a1141 2
/**/c_warning("%s - g_proc_CASE(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_CASE(spec=%d) */\n", spec);
d1770 7
a1776 2
/**/c_warning("%s - g_proc_SLEEP(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_SLEEP(spec=%d) */\n", spec);
@


1.34
log
@1995-Apr-24 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.33 1995/04/23 12:55:13 ldl Exp ldl $
d58 1
d596 1
a596 1
  fprintf(f, "  long long __nexpr");
d607 2
d611 1
a611 2

  fprintf(f, "  goto _call_return;\n");
d736 1
a736 1
        fprintf(f, "\t\t\t\t\t/* %-28s */\n", _parse.file);
d767 1
a767 1
/**/	  case T_FOR:		g_proc_FOR(d);			break;
d771 1
a771 1
/**/	  case T_IF:		g_proc_IF(d);			break;
d784 2
a785 2
/**/	  case T_REPEAT:	g_proc_REPEAT(d);		break;
/**/	  case T_RETURN:	g_proc_RETURN(d);		break;
d790 1
a790 1
/**/	  case T_UNLOCK:	g_proc_UNLOCK(d);		break;
d867 23
d1133 1
a1133 7
  e = rnn(d, T__STMT, NIL);		/* Get do stmt node		*/
  ng(e, &xt, &xs);			/* Get type of stmt		*/

  if (xt == T_BEGIN)
    g_proc_BEGIN(e);			/* Generate BEGIN-END block	*/
  else
    g_proc_code(e, 0);			/* Generate code for statement	*/
a1159 1
  --indent;
d1246 61
a1306 2
/**/c_warning("%s - g_proc_FOR(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_FOR(spec=%d) */\n", spec);
a1384 2
/**/c_warning("%s - g_proc_IF(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_IF(spec=%d) */\n", spec);
d1397 2
a1398 10
  e = rnn(d, T_THEN, NIL);		/* Get THEN stmt node		*/
  ng(e, &xt, &xs);			/* Get type of stmt		*/
  if (xt == T_BEGIN)
    g_proc_BEGIN(e);			/* Generate BEGIN-END block	*/
  else
    {
      ++indent;
      g_proc_code(e, 0);		/* Generate code for statement	*/
      --indent;
    }
a1403 1
      ng(e, &xt, &xs);			/* Get type of stmt		*/
d1405 1
a1405 8
      if (xt == T_BEGIN)
        g_proc_BEGIN(e);		/* Generate BEGIN-END block	*/
      else
        {
          ++indent;
          g_proc_code(e, 0);		/* Generate code for statement	*/
          --indent;
	}
d1561 10
d1576 20
a1595 2
/**/c_warning("%s - g_proc_REPEAT(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_REPEAT(spec=%d) */\n", spec);
d1677 5
a1681 6
  Node_id   d, s;
/**/c_warning("%s - g_proc_UNLOCK(spec=%d)", _parse.file, spec);
  fprintf(f, "  /* g_proc_UNLOCK(spec=%d) */\n", spec);
  s = rnn(spec, T__FIRST, NIL);		/* Get specification list	*/
  if (d = rnn(s, T_O_LPAREN, NIL))	/* Get channel descriptor	*/
    g_proc_iochannel(d);		/* Leave channel in __iexpr	*/
d1738 1
a1738 7
  e = rnn(d, T__STMT, NIL);		/* Get while stmt node		*/
  ng(e, &xt, &xs);			/* Get type of stmt		*/

  if (xt == T_BEGIN)
    g_proc_BEGIN(e);			/* Generate BEGIN-END block	*/
  else
    g_proc_code(e, 0);			/* Generate code for statement	*/
d1810 1
a1810 1
  fprintf(f, "%*sio_channel = (int)_nexpr;\n", INDENT);
@


1.33
log
@1995-Apr-23 Checkpoint (a.m.)
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.32 1995/04/22 12:42:51 ldl Exp ldl $
a247 1
	ng(rnn(t, T__TYPE, NIL), &xt, &xs);
d249 3
a251 1
	strcat(decl, find_string(t, T__SIZE_BUFFER));
d253 1
d565 1
a565 1
  int       r;
d595 4
a598 1
  fprintf(f, "  long long __nexpr, __ntemp[%d];\n", MAX_NTEMP);
d944 1
d1302 6
d1310 39
@


1.32
log
@1995-Apr-22 Checkpoint (a.m.)
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.31 1995/04/19 11:29:08 ldl Exp ldl $
a37 1
#define MAX_NTEMP 5
a43 5
void      ntemp_free	PROTOARGS((int)),
          ntemp_freeall PROTOARGS((void));
static
int       ntemp_get	PROTOARGS((void));
static
a132 2
char      __ntemp[MAX_NTEMP];		/* Numeric temp usage map	*/
static
d592 2
a594 1
  fprintf(f, "  long long __ntemp[%d];\n", MAX_NTEMP);
d596 1
a596 1
  fprintf(f, "  char     *__errortrap = (char *)NULL;\n");
d695 1
a695 1
  fprintf(f, "  if (__errortrap == (char *)0) goto _error_trap_FATAL;\n");
d848 3
a850 2
/**/printf("g_proc_decl_params: spec=%d\n", spec);
/***/
d867 1
d902 1
d959 1
d1021 1
d1046 1
d1056 1
a1056 1
      fprintf(f, "%*sdrt_display(__iexpr, 1/*spec=[%d]*/);\n",
d1080 2
a1081 1
/**/printf("g_proc_DO(spec=%d) l_uid=%d\n", spec, l_uid);
d1113 3
a1115 1
      fprintf(f, "%*sif ( %s )\n", INDENT, xs = c_nexpr(e));
a1116 1
      free(xs);
d1201 1
d1213 1
d1222 1
d1232 1
d1244 1
d1267 2
a1268 2
	xs = c_nexpr(rnn(d, T__EXPR, NIL));
	fprintf(f, "%*s__iexpr = %s;\n", INDENT, xs);
d1296 1
d1362 1
d1409 1
d1422 1
d1435 1
d1447 1
d1456 1
d1473 1
d1482 1
d1530 1
d1540 1
d1574 1
d1589 2
a1590 1
/**/printf("g_proc_WHILE(spec=%d) l_uid=%d\n", spec, l_uid);
d1615 3
a1617 1
      fprintf(f, "%*sif ( %s )\n", INDENT, xs = c_nexpr(e));
a1618 1
      free(xs);
d1636 1
d1649 1
d1661 1
d1678 2
a1679 26
  char      chref[100], szbuf[10];
  char     *ref, *size, *type;
  int       xt;

  ng(spec, &xt, &ref);
  switch (xt)
    {
      case T_ID:
        c_ref(spec, &ref, &size, &type);
	sprintf(chref, "dbl_int(%.*s, %s, \"%s\")",
	        strlen(ref) - 1, ref, size, type);
	break;
      case T_NUMBER:
	sprintf(szbuf, "D%d", strlen(ref));
	/* fall-thru */
      case T_STRING:
	if (xt == T_STRING)
	  sprintf(szbuf, "A%d", strlen(ref));
	type = &szbuf[0];
	size = &szbuf[1];
	sprintf(chref, "dbl_int(\"%s\", %s, \"%s\")", ref, size, type);
	break;
      default:
	c_error("%s - internal error iochannel xt=%d\n", _parse.file, xt);
    }
  fprintf(f, "%*s__iexpr = %s;\n", INDENT, chref);
a1680 43

/**
 *	Free a numeric temporary register 'r'.
 */
static
void
ntemp_free(r)						/* Function	*/
  int       r;
{
  assert("r", r, 0, r < 0 || r >= MAX_NTEMP);
  __ntemp[r] = 0;
} /* ntemp_free */

/**
 *	Free all numeric temporary registers.
 */
static
void
ntemp_freeall()						/* Function	*/
{
  int       r;
  for (r = 0;  r < MAX_NTEMP;  ++r)
    ntemp_free(r);			/* Yeah, it's overkill to call()*/
} /* ntemp_freeall */

/**
 *	Get a numeric termporary.
 */
static
int
ntemp_get()						/* Function	*/
{
  int       r;
  for (r = 0;  r < MAX_NTEMP;  ++r)
    if (__ntemp[r] == 0)
      {
        __ntemp[r] = 1;			/* Set temporary active		*/
	return r;
      }
  c_error("internal error - ran out of numeric temporaries, MAX_NTEMP=%d",
          MAX_NTEMP);
  return -1;
} /* ntemp_get */
@


1.31
log
@1995-Apr-19 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.30 1995/04/18 12:00:39 ldl Exp ldl $
d62 1
a62 1
	  g_proc_decl	PROTOARGS((char **)),
d111 2
a112 1
	  g_proc_XRETURN PROTOARGS((Node_id));
d120 4
d131 5
a135 1
char     *block[MAX_BLOCK_DEPTH];	/* Active block names		*/
d137 1
a137 1
char      cblock = -1;			/* No block active		*/
d551 1
a570 1
  char     *blkname;
d596 1
a596 1
  g_proc_decl(&blkname);		/* Introduce the routine	*/
d600 1
d610 2
d640 2
a641 2
  fprintf(f, " *   (stack empty), then there was an extraneous RETURN,\n");
  fprintf(f, " *   which results in a fatal error.\n");
d645 1
a645 1
  fprintf(f, "  if (__call_stack < 0) goto _call_return_FATAL;\n");
d655 25
a679 3
  fprintf(f, "  /* Fall-thru to FATAL */\n");
  fprintf(f, "_call_return_FATAL:\n");
  fprintf(f, "  drt__FATAL(\"RETURN with no active CALL\");\n");
d756 1
a756 1
/**/	  case T_CLOSE:		g_proc_CLOSE(d);		break;
d759 1
a759 1
/**/	  case T_DETACH:	g_proc_DETACH(d);		break;
d763 1
a763 1
/**/	  case T_EXIT:		g_proc_EXIT(d);			break;
d797 1
a797 1
/**/	  case T_XRETURN:	g_proc_XRETURN(d);		break;
d804 1
a804 2
g_proc_decl(blkname)					/* Function	*/
  char    **blkname;
d823 1
a823 1
  if (d = rnn(_parse.tree, T__TYPE, NIL))
d825 1
a825 1
      ng(d, &xt, blkname);
d830 1
a830 1
      *blkname = CDBL_MAIN;
d833 2
a834 2
  fprintf(f, "%s(", *blkname);		/* Generate formal param list	*/
  indent = strlen(*blkname) + 2;	/* Indent interpreted 1:1	*/
d842 1
d869 1
d873 3
a876 1
  left   = c_ref (rnn(spec, T__LEFT,   NIL));
a880 5
  fprintf(f, "%*s/* g_proc_assign(spec=%d)\n", INDENT, spec);
  fprintf(f, "%*s *   left   = \"%s\"\n",      INDENT, left);
  fprintf(f, "%*s *   right  = \"%s\"\n",      INDENT, right);
  fprintf(f, "%*s *   format = \"%s\"\n",      INDENT, format);
  fprintf(f, "%*s */\n",                       INDENT);
a881 1
  free(left);
d885 15
d915 2
d918 1
a918 1
  fprintf(f, "%*s/* BEGIN */\n", INDENT);
d920 3
a922 1
  if (lab = find_string(spec, T_LABEL))
d924 2
a925 5
      if (++cblock < MAX_BLOCK_DEPTH)
        block[cblock] = lab;		/* Stash active block label	*/
      else
        c_error("%s - MAX_BLOCK_DEPTH of %d exceeded",
	        _parse.file, MAX_BLOCK_DEPTH);
d927 8
d938 5
a942 5
  if (lab)				/* Make block inactive		*/
    {
      fprintf(f, "%s_exit:\n", lab);	/* Post exit tag for "EXIT blk"	*/
      --cblock;				/* Remove from active context	*/
    }
d985 9
a993 1
  fprintf(f, "  /* g_proc_CLOSE(spec=%d) */\n", spec);
d1023 1
d1025 3
d1035 1
a1035 1
  fprintf(f, "  /* g_proc_DETACH(spec=%d) */\n", spec);
d1050 1
a1050 27
    {
      char      chref[100];
      int       xt;
      ng(d, &xt, &ref);
      switch (xt)
        {
	  case T_ID:
            c_ref(d, &ref, &size, &type);
	    sprintf(chref, "dbl_int(%.*s, %s, \"%s\")",
	            strlen(ref) - 1, ref, size, type);
	    break;
	  case T_NUMBER:
	    sprintf(szbuf, "D%d", strlen(ref));
	    /* fall-thru */
	  case T_STRING:
	    if (xt == T_STRING)
	      sprintf(szbuf, "A%d", strlen(ref));
	    type = &szbuf[0];
	    size = &szbuf[1];
	    sprintf(chref, "dbl_int(\"%s\", %s, \"%s\")", ref, size, type);
	    break;
	  default:
	    c_error("%s - internal error DISPLAY channel xt=%d\n",
	           _parse.file, xt);
	}
      fprintf(f, "%*s__iexpr = %s;\n", INDENT, chref);
    }
d1057 1
a1057 1
      fprintf(f, "%*sdbl_display(__iexpr, 1/*spec=[%d]*/);\n",
d1100 1
a1100 1
  fprintf(f, "loop_%04d_top: /* %s */\n", l_uid, to_token(xt) );
d1102 7
a1108 1
  g_proc_code(rnn(d, T__STMT, NIL), 0);	/* Generate code for statement	*/
d1110 1
a1110 1
  fprintf(f, "loop_%04d_bottom:\n", l_uid);
d1119 1
a1119 1
  fprintf(f, "loop_%04d_exit:\n", l_uid);
d1130 4
a1134 1
  fprintf(f, "%*s/* END */\n", INDENT);
a1143 1
  fprintf(f, "  /* g_proc_EXIT(spec=%d) */\n", spec);
a1146 1
/**/printf("g_proc_EXIT: look for block %s\n", lab);
d1148 3
a1150 1
        if (strcmp(lab, block[i]) == 0)	/* Found - block is active	*/
d1155 18
a1172 1
      c_error("%s - EXIT not in context of block %s", _parse.file, lab);
d1175 6
a1180 1
    fprintf(f, "/* EXIT  NOT IMPLEMENTED YET*/\n");
d1199 1
d1201 3
d1227 1
d1229 3
d1400 1
d1402 3
d1412 1
d1414 3
d1424 1
d1426 3
d1523 1
d1525 3
d1574 1
a1574 1
  fprintf(f, "loop_%04d_top:\n", l_uid);
d1582 7
a1588 1
  g_proc_code(rnn(d, T__STMT, NIL), 0);	/* Generate code for statement	*/
d1593 1
a1593 1
  fprintf(f, "loop_%04d_bottom:\n", l_uid);
d1607 1
a1607 1
  fprintf(f, "loop_%04d_exit:\n", l_uid);
d1615 1
d1617 3
d1627 1
d1629 3
d1647 1
a1647 1
  fprintf(f, "  /* g_proc_XRETURN(spec=%d) */\n", spec);
d1649 33
@


1.30
log
@1995-Apr-18 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.29 1995/04/13 10:23:55 ldl Exp ldl $
d13 9
d38 2
d45 5
d59 1
d126 6
d570 17
d591 2
d596 1
a600 1

d617 34
d719 1
a719 1
/**/	  case T_CALL:		g_proc_CALL(d);			break;
d869 1
d872 16
d895 6
a900 1
  fprintf(f, "  /* g_proc_CALL(spec=%d) */\n", spec);
a975 1
  char      chref[100];
d984 1
d1008 1
d1010 2
d1016 2
a1017 2
      fprintf(f, "%*sdbl_display(%s /*spec=[%d]*/);\n",
             INDENT, chref, /**/ d
d1092 2
d1095 15
d1360 1
a1360 1
  fprintf(f, "  /* g_proc_RETURN(spec=%d) */\n", spec);
d1539 43
@


1.29
log
@1995-Apr-13 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.28 1995/04/03 11:47:10 ldl Exp ldl $
d96 1
a96 1
char     *to_c_filename	PROTOARGS((char *));
d102 2
a103 1
FILE     *f = (FILE *)NULL;		/* The output file descriptor	*/
d117 3
a119 2
  if ( ! _parse.out )
    _parse.out = to_c_filename(_parse.file);
d121 1
d135 5
a139 2
  fprintf(f, "\n\n");
  fprintf(f, "/* End of %s : written by %s */\n", _parse.out, ver);
d141 1
d508 12
d528 1
a528 1
  if ( ! (f = fopen(_parse.out, "w")) )	/* Oops, can't open file??	*/
d530 2
d601 1
a601 3
  fprintf(f, "  fprintf(f, \"%s\", __errortrap);\n",
          "FATAL ERROR: No label \\\"%s\\\" for ONERROR\\n"
	 );
d640 2
a641 2
	  case T_O_EQUAL:	g_proc_assign(d);		break;
	  case T_ACCEPT:	g_proc_ACCEPT(d);		break;
d643 2
a644 2
	  case T_CALL:		g_proc_CALL(d);			break;
	  case T_CASE:		g_proc_CASE(d);			break;
d646 1
a646 1
	  case T_CLOSE:		g_proc_CLOSE(d);		break;
d648 3
a650 3
	  case T_DELETE:	g_proc_DELETE(d);		break;
	  case T_DETACH:	g_proc_DETACH(d);		break;
	  case T_DISPLAY:	g_proc_DISPLAY(d);		break;
d653 1
a653 1
	  case T_EXIT:		g_proc_EXIT(d);			break;
d655 5
a659 5
	  case T_FIND:		g_proc_FIND(d);			break;
	  case T_FLUSH:		g_proc_FLUSH(d);		break;
	  case T_FOR:		g_proc_FOR(d);			break;
	  case T_FORMS:		g_proc_FORMS(d);		break;
	  case T_FRETURN:	g_proc_FRETURN(d);		break;
d661 1
a661 1
	  case T_IF:		g_proc_IF(d);			break;
d665 1
a665 1
	  case T_LPQUE:		g_proc_LPQUE(d);		break;
d670 8
a677 8
	  case T_OPEN:		g_proc_OPEN(d);			break;
	  case T_READ:		g_proc_READ(d);			break;
	  case T_READS:		g_proc_READS(d);		break;
	  case T_RECV:		g_proc_RECV(d);			break;
	  case T_REPEAT:	g_proc_REPEAT(d);		break;
	  case T_RETURN:	g_proc_RETURN(d);		break;
	  case T_SEND:		g_proc_SEND(d);			break;
	  case T_SLEEP:		g_proc_SLEEP(d);		break;
d679 2
a680 2
	  case T_STORE:		g_proc_STORE(d);		break;
	  case T_UNLOCK:	g_proc_UNLOCK(d);		break;
d682 1
a682 1
	  case T_USING:		g_proc_USING(d);		break;
d684 4
a687 4
	  case T_WRITE:		g_proc_WRITE(d);		break;
	  case T_WRITES:	g_proc_WRITES(d);		break;
	  case T_XCALL:		g_proc_XCALL(d);		break;
	  case T_XRETURN:	g_proc_XRETURN(d);		break;
d851 1
d878 41
a918 1
  fprintf(f, "  /* g_proc_DISPLAY(spec=%d) */\n", spec);
d999 3
a1001 1
  fprintf(f, "  /* g_proc_EXITLOOP(spec=%d) */\n", spec);
d1111 1
d1123 5
a1127 4
  char     *xs;
  ng(spec, &xt, &xs);
  fprintf(f, "%s:%.*s/* LABEL\t*/\n", xs,
	  (64 - strlen(xs) - 2) / 8, "\t\t\t\t\t\t\t");
d1135 15
a1149 1
  fprintf(f, "  /* g_proc_LOCASE(spec=%d) */\n", spec);
d1266 32
a1297 1
  fprintf(f, "  /* g_proc_STOP(spec=%d) */\n", spec);
d1321 15
a1335 1
  fprintf(f, "  /* g_proc_UPCASE(spec=%d) */\n", spec);
d1423 1
a1423 1
 *	Strip suffix, replacing with .c, with the following behaviors:
d1431 1
a1431 1
to_c_filename(name)					/* Function	*/
d1433 1
d1444 3
a1446 2
  s = (char *) u_malloc(ln + 3);	/* Allocate enuf for "name.c\0"	*/
  sprintf(s, "%.*s.c", ln, name);	/* Create new name		*/
@


1.28
log
@1995-Apr-03 Checkpoint.
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.27 1995/03/27 03:06:27 ldl Exp ldl $
d43 1
d201 3
a203 1
	if (a = rnn(t, T_O_LBRACK, NIL))
d530 1
d533 1
d554 34
d829 1
a829 1
        c_error("cannot increment non-number field %s", ref);
d910 1
a910 1
    fprintf(f, "%*sgoto loop_%04d_top;\n", l_uid);
d923 1
a923 1
  fprintf(f, "%*s/*_END */\n", INDENT);
d1046 1
a1046 1
        c_error("cannot increment non-number field %s", ref);
d1097 1
a1097 1
  fprintf(f, "  /* g_proc_NOP(spec=%d) */\n", spec);
d1105 1
a1105 1
  fprintf(f, "  /* g_proc_OFFERROR(spec=%d) */\n", spec);
d1113 4
a1116 1
  fprintf(f, "  /* g_proc_ONERROR(spec=%d) */\n", spec);
@


1.27
log
@26-Mar-1995 Checkpoint 2
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.26 1995/03/26 19:58:13 ldl Exp ldl $
d702 3
d708 2
d715 1
d719 1
d760 7
a766 1
  fprintf(f, "  /* g_proc_CLEAR(spec=%d) */\n", spec);
d782 14
a795 1
  fprintf(f, "  /* g_proc_DECR(spec=%d) */\n", spec);
d1000 13
a1012 4
  char     *xs;
  d = rnn(spec, T__FIRST, NIL);
  fprintf(f, "%*sdrt_incr(%s);\n", INDENT, xs = c_ref(d));
  free(xs);
@


1.26
log
@26-Mar-1995 Checkpoint 1
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.25 1995/03/23 13:31:32 ldl Exp ldl $
d567 2
a568 2
      if (xs = find_string(d, T__FILE_LINENO))
        fprintf(f, "\t\t\t\t\t/* %-28s */\n", xs);
d932 1
a932 2
	  c_error("%s - no label \"%s\" in program",
                  find_string(spec, T__FILE_LINENO), xs);
d946 1
a946 2
	      c_error("%s - no label \"%s\" in program",
                      find_string(spec, T__FILE_LINENO), xs);
d1014 1
a1014 2
    c_error("%s - NEXTLOOP not inside a loop context",
            find_string(spec, T__FILE_LINENO));
@


1.25
log
@23-Mar-1995 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.24 1995/03/19 23:29:18 ldl Exp ldl $
d26 5
d42 1
d105 2
d526 1
d535 12
d557 7
d568 1
a568 1
        fprintf(f, "%s\n", xs);
d570 2
d575 1
a575 1
            fprintf(f, "%*s/* OP %s%s%s spec=%d*/\n",  indent * 2, "",
d578 1
a578 1
	    fprintf(f, "%*s      ^^^^^^^ %s\n", indent * 2, "",
d705 8
a712 5
  fprintf(f, "%*s/* g_proc_assign(spec=%d)\n", indent * 2, "", spec);
  fprintf(f, "%*s *   left   = \"%s\"\n",      indent * 2, "", left);
  fprintf(f, "%*s *   right  = \"%s\"\n",      indent * 2, "", right);
  fprintf(f, "%*s *   format = \"%s\"\n",      indent * 2, "", format);
  fprintf(f, "%*s */\n",                       indent * 2, "");
d728 2
a729 1
  fprintf(f, "  /* g_proc_BEGIN(spec=%d) */\n", spec);
d796 7
d808 42
a849 1
  fprintf(f, "  /* g_proc_DO(spec=%d) */\n", spec);
d857 2
a858 1
  fprintf(f, "  /* g_proc_END(spec=%d) */\n", spec);
d922 38
a959 1
  fprintf(f, "  /* g_proc_GOTO(spec=%d) */\n", spec);
d975 5
a979 1
  fprintf(f, "  /* g_proc_INCR(spec=%d) */\n", spec);
d1015 4
a1018 1
  fprintf(f, "  /* g_proc_NEXTLOOP(spec=%d) */\n", spec);
d1154 37
a1190 1
  fprintf(f, "  /* g_proc_WHILE(spec=%d) */\n", spec);
@


1.24
log
@19-Mar-1995 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.23 1995/03/08 13:33:27 ldl Exp ldl $
d396 1
@


1.23
log
@08-Mar-1995 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.22 1995/03/06 12:00:16 ldl Exp ldl $
d29 59
a87 1
void      g_close_file	PROTOARGS((void));
a88 114
void      g_data_buffers PROTOARGS((Node_id, int));
static
void      g_data_defs	PROTOARGS((void));
static
void      g_data_init	PROTOARGS((Node_id));
static
void      g_data_init_ele PROTOARGS((Node_id, int, int));
static
void      g_header	PROTOARGS((void));
static
void      g_open_file	PROTOARGS((void));
static
void      g_proc	PROTOARGS((void));
static
void      g_proc_code	PROTOARGS((Node_id, int));
static
void      g_proc_decl	PROTOARGS((char **));
static
void      g_proc_decl_params PROTOARGS((Node_id, int));
static
void      g_proc_assign PROTOARGS((Node_id));
static
void      g_proc_ACCEPT	PROTOARGS((Node_id));
static
void      g_proc_BEGIN	PROTOARGS((Node_id));
static
void      g_proc_CALL	PROTOARGS((Node_id));
static
void      g_proc_CASE	PROTOARGS((Node_id));
static
void      g_proc_CLEAR	PROTOARGS((Node_id));
static
void      g_proc_CLOSE	PROTOARGS((Node_id));
static
void      g_proc_DECR	PROTOARGS((Node_id));
static
void      g_proc_DELETE	PROTOARGS((Node_id));
static
void      g_proc_DETACH	PROTOARGS((Node_id));
static
void      g_proc_DISPLAY PROTOARGS((Node_id));
static
void      g_proc_DO	PROTOARGS((Node_id));
static
void      g_proc_END	PROTOARGS((Node_id));
static
void      g_proc_EXIT	PROTOARGS((Node_id));
static
void      g_proc_EXITLOOP PROTOARGS((Node_id));
static
void      g_proc_FIND	PROTOARGS((Node_id));
static
void      g_proc_FLUSH	PROTOARGS((Node_id));
static
void      g_proc_FOR	PROTOARGS((Node_id));
static
void      g_proc_FORMS	PROTOARGS((Node_id));
static
void      g_proc_FRETURN PROTOARGS((Node_id));
static
void      g_proc_GOTO	PROTOARGS((Node_id));
static
void      g_proc_IF	PROTOARGS((Node_id));
static
void      g_proc_INCR	PROTOARGS((Node_id));
static
void      g_proc_LOCASE	PROTOARGS((Node_id));
static
void      g_proc_LPQUE	PROTOARGS((Node_id));
static
void      g_proc_NEXTLOOP PROTOARGS((Node_id));
static
void      g_proc_NOP	PROTOARGS((Node_id));
static
void      g_proc_OFFERROR PROTOARGS((Node_id));
static
void      g_proc_ONERROR PROTOARGS((Node_id));
static
void      g_proc_OPEN	PROTOARGS((Node_id));
static
void      g_proc_READ	PROTOARGS((Node_id));
static
void      g_proc_READS	PROTOARGS((Node_id));
static
void      g_proc_RECV	PROTOARGS((Node_id));
static
void      g_proc_REPEAT	PROTOARGS((Node_id));
static
void      g_proc_RETURN	PROTOARGS((Node_id));
static
void      g_proc_SEND	PROTOARGS((Node_id));
static
void      g_proc_SLEEP	PROTOARGS((Node_id));
static
void      g_proc_STOP	PROTOARGS((Node_id));
static
void      g_proc_STORE	PROTOARGS((Node_id));
static
void      g_proc_UNLOCK	PROTOARGS((Node_id));
static
void      g_proc_UPCASE	PROTOARGS((Node_id));
static
void      g_proc_USING	PROTOARGS((Node_id));
static
void      g_proc_WHILE	PROTOARGS((Node_id));
static
void      g_proc_WRITE	PROTOARGS((Node_id));
static
void      g_proc_WRITES	PROTOARGS((Node_id));
static
void      g_proc_XCALL	PROTOARGS((Node_id));
static
void      g_proc_XRETURN PROTOARGS((Node_id));
static
a539 13
      { /* block */			/* Put label(s) into code	*/
        Node_id   a;
        int       ar;
	ar = T__FIRST;
	if (a  = rnn(d, T_LABEL, NIL))	/* If there is a label		*/
	  do
	    {
	      ng(a, &xt, &xs);
              fprintf(f, "%s:%.*s/* LABEL\t*/\n", xs,
	              (64 - strlen(xs) - 2) / 8, "\t\t\t\t\t\t\t");
	    }
	  while (a = rnn(a, ar, NIL), ar = T__PRECEDES, a);
      } /* block */			/* Put label(s) into code	*/
d574 1
d856 12
@


1.22
log
@06-Mar-1995 Checkpoint 2
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.21 1995/03/06 10:31:57 ldl Exp ldl $
d594 15
a609 3
      fprintf(f, "%*s/* OP %s%s%s */\n", indent * 2, "",
              to_token(xt), xs ? ":" : "", xs ? xs : ""
	     );
d613 3
d680 9
a688 1
  fprintf(f, "\n/* %s%s\t*/\n\n",
d738 9
a746 1
  fprintf(f, "g_proc_assign(spec=%d)\n", spec);
d754 1
a754 1
  fprintf(f, "g_proc_ACCEPT(spec=%d)\n", spec);
d762 1
a762 1
  fprintf(f, "g_proc_BEGIN(spec=%d)\n", spec);
d770 1
a770 1
  fprintf(f, "g_proc_CALL(spec=%d)\n", spec);
d778 1
a778 1
  fprintf(f, "g_proc_CASE(spec=%d)\n", spec);
d786 1
a786 1
  fprintf(f, "g_proc_CLEAR(spec=%d)\n", spec);
d794 1
a794 1
  fprintf(f, "g_proc_CLOSE(spec=%d)\n", spec);
d802 1
a802 1
  fprintf(f, "g_proc_DECR(spec=%d)\n", spec);
d810 1
a810 1
  fprintf(f, "g_proc_DELETE(spec=%d)\n", spec);
d818 1
a818 1
  fprintf(f, "g_proc_DETACH(spec=%d)\n", spec);
d826 1
a826 1
  fprintf(f, "g_proc_DISPLAY(spec=%d)\n", spec);
d834 1
a834 1
  fprintf(f, "g_proc_DO(spec=%d)\n", spec);
d842 1
a842 1
  fprintf(f, "g_proc_END(spec=%d)\n", spec);
d850 1
a850 1
  fprintf(f, "g_proc_EXIT(spec=%d)\n", spec);
d858 1
a858 1
  fprintf(f, "g_proc_EXITLOOP(spec=%d)\n", spec);
d866 1
a866 1
  fprintf(f, "g_proc_FIND(spec=%d)\n", spec);
d874 1
a874 1
  fprintf(f, "g_proc_FLUSH(spec=%d)\n", spec);
d882 1
a882 1
  fprintf(f, "g_proc_FOR(spec=%d)\n", spec);
d890 1
a890 1
  fprintf(f, "g_proc_FORMS(spec=%d)\n", spec);
d898 1
a898 1
  fprintf(f, "g_proc_FRETURN(spec=%d)\n", spec);
d906 1
a906 1
  fprintf(f, "g_proc_GOTO(spec=%d)\n", spec);
d914 1
a914 1
  fprintf(f, "g_proc_IF(spec=%d)\n", spec);
d922 1
a922 1
  fprintf(f, "g_proc_INCR(spec=%d)\n", spec);
d930 1
a930 1
  fprintf(f, "g_proc_LOCASE(spec=%d)\n", spec);
d938 1
a938 1
  fprintf(f, "g_proc_LPQUE(spec=%d)\n", spec);
d946 1
a946 1
  fprintf(f, "g_proc_NEXTLOOP(spec=%d)\n", spec);
d954 1
a954 1
  fprintf(f, "g_proc_NOP(spec=%d)\n", spec);
d962 1
a962 1
  fprintf(f, "g_proc_OFFERROR(spec=%d)\n", spec);
d970 1
a970 1
  fprintf(f, "g_proc_ONERROR(spec=%d)\n", spec);
d978 1
a978 1
  fprintf(f, "g_proc_OPEN(spec=%d)\n", spec);
d986 1
a986 1
  fprintf(f, "g_proc_READ(spec=%d)\n", spec);
d994 1
a994 1
  fprintf(f, "g_proc_READS(spec=%d)\n", spec);
d1002 1
a1002 1
  fprintf(f, "g_proc_RECV(spec=%d)\n", spec);
d1010 1
a1010 1
  fprintf(f, "g_proc_REPEAT(spec=%d)\n", spec);
d1018 1
a1018 1
  fprintf(f, "g_proc_RETURN(spec=%d)\n", spec);
d1026 1
a1026 1
  fprintf(f, "g_proc_SEND(spec=%d)\n", spec);
d1034 1
a1034 1
  fprintf(f, "g_proc_SLEEP(spec=%d)\n", spec);
d1042 1
a1042 1
  fprintf(f, "g_proc_STOP(spec=%d)\n", spec);
d1050 1
a1050 1
  fprintf(f, "g_proc_STORE(spec=%d)\n", spec);
d1058 1
a1058 1
  fprintf(f, "g_proc_UNLOCK(spec=%d)\n", spec);
d1066 1
a1066 1
  fprintf(f, "g_proc_UPCASE(spec=%d)\n", spec);
d1074 1
a1074 1
  fprintf(f, "g_proc_USING(spec=%d)\n", spec);
d1082 1
a1082 1
  fprintf(f, "g_proc_WHILE(spec=%d)\n", spec);
d1090 1
a1090 1
  fprintf(f, "g_proc_WRITE(spec=%d)\n", spec);
d1098 1
a1098 1
  fprintf(f, "g_proc_WRITES(spec=%d)\n", spec);
d1106 1
a1106 1
  fprintf(f, "g_proc_XCALL(spec=%d)\n", spec);
d1114 1
a1114 1
  fprintf(f, "g_proc_XRETURN(spec=%d)\n", spec);
d1138 1
a1138 1
  s = malloc(ln + 3);			/* Allocate enuf for "name.c\0"	*/
@


1.21
log
@06-Mar-1995 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.20 1995/03/05 03:24:36 ldl Exp ldl $
d45 2
d51 94
a571 5
					/* Look up proc division	*/
  d = rnn(_parse.tree, T__DIVISION, NIL);
  for (r = T__FIRST;  d = rnn(d, r, NIL);  r = T__PRECEDES)
    if (rnn(d, T_PROC, NIL))
      break;
d574 2
a575 1
  fprintf(f, "  /* rest of code here */\n");
d583 75
a688 2
  indent = 0;				/* Indent level			*/

d709 376
@


1.20
log
@04-Mar-1995 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.19 1995/03/03 12:36:18 ldl Exp ldl $
d19 1
d29 1
a29 1
void      g_close_file	PROTOARGS(());
d31 1
a31 1
void      g_data_buffers PROTOARGS(());
d33 1
a33 1
void      g_data_defs	PROTOARGS(());
d39 1
a39 1
void      g_header	PROTOARGS(());
d41 1
a41 1
void      g_open_file	PROTOARGS(());
d43 1
a43 1
void      g_proc	PROTOARGS(());
d45 4
d71 5
a75 5
  g_open_file();
  g_header();
  g_data_defs();
  g_proc();
  g_close_file();
d92 1
a92 1
g_data_buffers(spec)					/* Function	*/
d94 1
d131 5
a135 2
  fprintf(f, "%*sstruct\n", indent++ * 2, "");
  fprintf(f, "%*s{\n",      indent++ * 2, "");
d190 5
a194 2
  fprintf(f, "%*s}       %s", --indent * 2, "", bufnm);
  --indent;
d210 3
a212 1
  fprintf(f, ";\n");
d223 1
a223 1
  walk_data_divs(g_data_buffers);
d465 6
a470 1
  /* NOTE: NOT ALWAYS A MAIN!! Just for now! */
d473 8
a480 4
  fprintf(f, "\n");
  fprintf(f, "main(argc, argv)\t\t\t/* Program\t*/\n");
  fprintf(f, "  int       argc;\n");
  fprintf(f, "  char    **argv;\n");
d482 5
a486 3
  fprintf(f, "  /* procedural code here */\n");
  fprintf(f, "} /* main */\n");
  fprintf(f, "\n");
d488 56
@


1.19
log
@03-Mar-1995 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.18 1995/02/27 12:55:27 ldl Exp ldl $
d13 1
d16 1
d34 1
a34 1
void      g_data_fields	PROTOARGS(());
d36 2
d53 2
d79 1
a79 1
  fprintf(f, "/* End of %s : written by cdbl */\n", _parse.out);
d99 1
a99 1
/**/printf("g_data_buffers: spec=%d\n", spec);
d107 1
a107 1
/**/printf("g_data_buffers: lastspec=%d\n", lastspec);
d139 2
a140 2
        Node_id   a,			/* Array dimension descriptor	*/
	          tt;			/* Type attr of type descriptor	*/
d142 1
a142 2
	tt = rnn(t, T__TYPE, NIL);	/* Get type attr of type	*/
        fprintf(f, "%*schar    %s", indent * 2, "", find_string(d, T_LABEL));
d146 3
a148 1
	    fprintf(f, "[%s]", xs);
d152 3
a154 1
	        fprintf(f, "[%s]", xs);
d158 6
a163 1
	fprintf(f, "[%s]; /* %s */\n", find_string(t, T__SIZE_BUFFER), xs);
d168 2
a169 1
/**/printf("g_data_buffers: %s hasinit\n", bufnm);
d190 1
a190 1
      lastspec = NIL;			/* Clear (avoid future hits)	*/
d195 2
a196 3
      fprintf(f, "\n= {\n");
      fprintf(f, "    0 /* other initializers here */\n");
      fprintf(f, "  }");
a209 1
  g_data_fields();
d214 58
a271 1
g_data_fields()						/* Function	*/
d273 102
a374 1
} /* g_data_fields */
d397 9
d414 2
a415 1
  fprintf(f, " * This program was created by cdbl using the command line:\n");
@


1.18
log
@27-Feb-1995 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.17 1995/02/26 10:54:27 ldl Exp ldl $
d47 2
d81 2
a82 2
g_data_buffers(div)					/* Function	*/
  Node_id   div;
d84 101
d191 1
d228 2
a229 2
  fprintf(f, " * $Locker$ $Header$\n");
  fprintf(f, " * $Source$\n");
@


1.17
log
@26-Feb-1995 Checkpoint
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.16 1995/01/07 15:34:52 ldl Exp ldl $
d26 14
d45 2
d57 7
d66 113
d204 1
@


1.16
log
@07-Jan-1995 Checkpoint 2
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.15 1995/01/07 11:22:34 ldl Exp ldl $
d7 1
a7 1
 *	Resolve various elements in symbol table.
a8 2
 *	Assign buffer offsets and look for duplicate entries.
 *
d14 1
a21 1
#if 0
d26 1
a26 1
void      follow_nodes	PROTOARGS((FILE *, Node_id, int, int));
d29 1
a29 2
 *	The following control the management of the "net" as defined in
 *	node.h.  These are local to this routine.
a30 4
static
Node_id   m_net = 0,			/* Currently (max) allocated	*/
          n_net = 1;			/* Next node to use (0=reserved)*/
#endif
d33 1
a33 4
 *	Initialize the net to an initial size of m_node.  If the net
 *	exists, it is grown by m_node entries.  (At this time, there is
 *	no "clearing" of nodes, nor re-use.  It is expected that the net
 *	is a build-only form - no re-init.)
d38 3
a40 1
  int       m_node;
d43 25
@


1.15
log
@07-Jan-1995 Checkpoint 1
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.14 1994/12/31 02:31:30 ldl Exp ldl $
@


1.14
log
@30-Dec-1994 Checkpoint 2
@
text
@d3 1
a3 1
 * $Header: /home/ldl/dbl/cdbl/RCS/generate.c,v 1.13 1994/12/30 21:01:48 ldl Exp ldl $
@


1.13
log
@30-Dec-1994 Checkpoint 1
@
text
@d2 2
a3 2
 * $Locker$ $Source$
 * $Header$
d52 1
a52 1
/* End of $Source$ */
@
